/*
 * This file is automatically generated.
 */
#ifndef aw_gl_ext_opengl_h
#define aw_gl_ext_opengl_h
#include "types.h"

namespace aw {
namespace gl {
namespace ext {
struct load_result {
	explicit operator bool() const
	{
		return is_loaded;
	}
	
	int num_missing() const { return missing; }
	
	load_result() = default;
	load_result(bool is_loaded, int num_missing)
		: is_loaded{is_loaded}, missing{num_missing}
	{}

private:
	bool is_loaded   = false;
	int  missing = 0;
};

} //namespace ext

namespace sys {

ext::load_result load_functions_3_3();

int get_minor_version();
int get_major_version();
bool is_version_geq(int major, int minor);
} //namespace sys

enum {
	/* gl version 1.1 */
	ALPHA                            = 0x1906,
	ALWAYS                           = 0x0207,
	AND                              = 0x1501,
	AND_INVERTED                     = 0x1504,
	AND_REVERSE                      = 0x1502,
	BACK                             = 0x0405,
	BACK_LEFT                        = 0x0402,
	BACK_RIGHT                       = 0x0403,
	BLEND                            = 0x0BE2,
	BLEND_DST                        = 0x0BE0,
	BLEND_SRC                        = 0x0BE1,
	BLUE                             = 0x1905,
	BYTE                             = 0x1400,
	CCW                              = 0x0901,
	CLEAR                            = 0x1500,
	COLOR                            = 0x1800,
	COLOR_BUFFER_BIT                 = 0x00004000,
	COLOR_CLEAR_VALUE                = 0x0C22,
	COLOR_LOGIC_OP                   = 0x0BF2,
	COLOR_WRITEMASK                  = 0x0C23,
	COPY                             = 0x1503,
	COPY_INVERTED                    = 0x150C,
	CULL_FACE                        = 0x0B44,
	CULL_FACE_MODE                   = 0x0B45,
	CW                               = 0x0900,
	DECR                             = 0x1E03,
	DEPTH                            = 0x1801,
	DEPTH_BUFFER_BIT                 = 0x00000100,
	DEPTH_CLEAR_VALUE                = 0x0B73,
	DEPTH_COMPONENT                  = 0x1902,
	DEPTH_FUNC                       = 0x0B74,
	DEPTH_RANGE                      = 0x0B70,
	DEPTH_TEST                       = 0x0B71,
	DEPTH_WRITEMASK                  = 0x0B72,
	DITHER                           = 0x0BD0,
	DONT_CARE                        = 0x1100,
	DOUBLE                           = 0x140A,
	DOUBLEBUFFER                     = 0x0C32,
	DRAW_BUFFER                      = 0x0C01,
	DST_ALPHA                        = 0x0304,
	DST_COLOR                        = 0x0306,
	EQUAL                            = 0x0202,
	EQUIV                            = 0x1509,
	EXTENSIONS                       = 0x1F03,
	FALSE_                           = 0,
	FASTEST                          = 0x1101,
	FILL                             = 0x1B02,
	FLOAT                            = 0x1406,
	FRONT                            = 0x0404,
	FRONT_AND_BACK                   = 0x0408,
	FRONT_FACE                       = 0x0B46,
	FRONT_LEFT                       = 0x0400,
	FRONT_RIGHT                      = 0x0401,
	GEQUAL                           = 0x0206,
	GREATER                          = 0x0204,
	GREEN                            = 0x1904,
	INCR                             = 0x1E02,
	INT                              = 0x1404,
	INVALID_ENUM                     = 0x0500,
	INVALID_OPERATION                = 0x0502,
	INVALID_VALUE                    = 0x0501,
	INVERT                           = 0x150A,
	KEEP                             = 0x1E00,
	LEFT                             = 0x0406,
	LEQUAL                           = 0x0203,
	LESS                             = 0x0201,
	LINE                             = 0x1B01,
	LINEAR                           = 0x2601,
	LINEAR_MIPMAP_LINEAR             = 0x2703,
	LINEAR_MIPMAP_NEAREST            = 0x2701,
	LINES                            = 0x0001,
	LINE_LOOP                        = 0x0002,
	LINE_SMOOTH                      = 0x0B20,
	LINE_SMOOTH_HINT                 = 0x0C52,
	LINE_STRIP                       = 0x0003,
	LINE_WIDTH                       = 0x0B21,
	LINE_WIDTH_GRANULARITY           = 0x0B23,
	LINE_WIDTH_RANGE                 = 0x0B22,
	LOGIC_OP_MODE                    = 0x0BF0,
	MAX_TEXTURE_SIZE                 = 0x0D33,
	MAX_VIEWPORT_DIMS                = 0x0D3A,
	NAND                             = 0x150E,
	NEAREST                          = 0x2600,
	NEAREST_MIPMAP_LINEAR            = 0x2702,
	NEAREST_MIPMAP_NEAREST           = 0x2700,
	NEVER                            = 0x0200,
	NICEST                           = 0x1102,
	NONE                             = 0,
	NOOP                             = 0x1505,
	NOR                              = 0x1508,
	NOTEQUAL                         = 0x0205,
	NO_ERROR_                        = 0,
	ONE                              = 1,
	ONE_MINUS_DST_ALPHA              = 0x0305,
	ONE_MINUS_DST_COLOR              = 0x0307,
	ONE_MINUS_SRC_ALPHA              = 0x0303,
	ONE_MINUS_SRC_COLOR              = 0x0301,
	OR                               = 0x1507,
	OR_INVERTED                      = 0x150D,
	OR_REVERSE                       = 0x150B,
	OUT_OF_MEMORY                    = 0x0505,
	PACK_ALIGNMENT                   = 0x0D05,
	PACK_LSB_FIRST                   = 0x0D01,
	PACK_ROW_LENGTH                  = 0x0D02,
	PACK_SKIP_PIXELS                 = 0x0D04,
	PACK_SKIP_ROWS                   = 0x0D03,
	PACK_SWAP_BYTES                  = 0x0D00,
	POINT                            = 0x1B00,
	POINTS                           = 0x0000,
	POINT_SIZE                       = 0x0B11,
	POINT_SIZE_GRANULARITY           = 0x0B13,
	POINT_SIZE_RANGE                 = 0x0B12,
	POLYGON_MODE                     = 0x0B40,
	POLYGON_OFFSET_FACTOR            = 0x8038,
	POLYGON_OFFSET_FILL              = 0x8037,
	POLYGON_OFFSET_LINE              = 0x2A02,
	POLYGON_OFFSET_POINT             = 0x2A01,
	POLYGON_OFFSET_UNITS             = 0x2A00,
	POLYGON_SMOOTH                   = 0x0B41,
	POLYGON_SMOOTH_HINT              = 0x0C53,
	PROXY_TEXTURE_1D                 = 0x8063,
	PROXY_TEXTURE_2D                 = 0x8064,
	R3_G3_B2                         = 0x2A10,
	READ_BUFFER                      = 0x0C02,
	RED                              = 0x1903,
	RENDERER                         = 0x1F01,
	REPEAT                           = 0x2901,
	REPLACE                          = 0x1E01,
	RGB                              = 0x1907,
	RGB10                            = 0x8052,
	RGB10_A2                         = 0x8059,
	RGB12                            = 0x8053,
	RGB16                            = 0x8054,
	RGB4                             = 0x804F,
	RGB5                             = 0x8050,
	RGB5_A1                          = 0x8057,
	RGB8                             = 0x8051,
	RGBA                             = 0x1908,
	RGBA12                           = 0x805A,
	RGBA16                           = 0x805B,
	RGBA2                            = 0x8055,
	RGBA4                            = 0x8056,
	RGBA8                            = 0x8058,
	RIGHT                            = 0x0407,
	SCISSOR_BOX                      = 0x0C10,
	SCISSOR_TEST                     = 0x0C11,
	SET                              = 0x150F,
	SHORT                            = 0x1402,
	SRC_ALPHA                        = 0x0302,
	SRC_ALPHA_SATURATE               = 0x0308,
	SRC_COLOR                        = 0x0300,
	STENCIL                          = 0x1802,
	STENCIL_BUFFER_BIT               = 0x00000400,
	STENCIL_CLEAR_VALUE              = 0x0B91,
	STENCIL_FAIL                     = 0x0B94,
	STENCIL_FUNC                     = 0x0B92,
	STENCIL_INDEX                    = 0x1901,
	STENCIL_PASS_DEPTH_FAIL          = 0x0B95,
	STENCIL_PASS_DEPTH_PASS          = 0x0B96,
	STENCIL_REF                      = 0x0B97,
	STENCIL_TEST                     = 0x0B90,
	STENCIL_VALUE_MASK               = 0x0B93,
	STENCIL_WRITEMASK                = 0x0B98,
	STEREO                           = 0x0C33,
	SUBPIXEL_BITS                    = 0x0D50,
	TEXTURE                          = 0x1702,
	TEXTURE_1D                       = 0x0DE0,
	TEXTURE_2D                       = 0x0DE1,
	TEXTURE_ALPHA_SIZE               = 0x805F,
	TEXTURE_BINDING_1D               = 0x8068,
	TEXTURE_BINDING_2D               = 0x8069,
	TEXTURE_BLUE_SIZE                = 0x805E,
	TEXTURE_BORDER_COLOR             = 0x1004,
	TEXTURE_GREEN_SIZE               = 0x805D,
	TEXTURE_HEIGHT                   = 0x1001,
	TEXTURE_INTERNAL_FORMAT          = 0x1003,
	TEXTURE_MAG_FILTER               = 0x2800,
	TEXTURE_MIN_FILTER               = 0x2801,
	TEXTURE_RED_SIZE                 = 0x805C,
	TEXTURE_WIDTH                    = 0x1000,
	TEXTURE_WRAP_S                   = 0x2802,
	TEXTURE_WRAP_T                   = 0x2803,
	TRIANGLES                        = 0x0004,
	TRIANGLE_FAN                     = 0x0006,
	TRIANGLE_STRIP                   = 0x0005,
	TRUE_                            = 1,
	UNPACK_ALIGNMENT                 = 0x0CF5,
	UNPACK_LSB_FIRST                 = 0x0CF1,
	UNPACK_ROW_LENGTH                = 0x0CF2,
	UNPACK_SKIP_PIXELS               = 0x0CF4,
	UNPACK_SKIP_ROWS                 = 0x0CF3,
	UNPACK_SWAP_BYTES                = 0x0CF0,
	UNSIGNED_BYTE                    = 0x1401,
	UNSIGNED_INT                     = 0x1405,
	UNSIGNED_SHORT                   = 0x1403,
	VENDOR                           = 0x1F00,
	VERSION                          = 0x1F02,
	VIEWPORT                         = 0x0BA2,
	XOR                              = 0x1506,
	ZERO                             = 0,
	
	/* gl version 1.2 */
	ALIASED_LINE_WIDTH_RANGE         = 0x846E,
	BGR                              = 0x80E0,
	BGRA                             = 0x80E1,
	CLAMP_TO_EDGE                    = 0x812F,
	MAX_3D_TEXTURE_SIZE              = 0x8073,
	MAX_ELEMENTS_INDICES             = 0x80E9,
	MAX_ELEMENTS_VERTICES            = 0x80E8,
	PACK_IMAGE_HEIGHT                = 0x806C,
	PACK_SKIP_IMAGES                 = 0x806B,
	PROXY_TEXTURE_3D                 = 0x8070,
	SMOOTH_LINE_WIDTH_GRANULARITY    = 0x0B23,
	SMOOTH_LINE_WIDTH_RANGE          = 0x0B22,
	SMOOTH_POINT_SIZE_GRANULARITY    = 0x0B13,
	SMOOTH_POINT_SIZE_RANGE          = 0x0B12,
	TEXTURE_3D                       = 0x806F,
	TEXTURE_BASE_LEVEL               = 0x813C,
	TEXTURE_BINDING_3D               = 0x806A,
	TEXTURE_DEPTH                    = 0x8071,
	TEXTURE_MAX_LEVEL                = 0x813D,
	TEXTURE_MAX_LOD                  = 0x813B,
	TEXTURE_MIN_LOD                  = 0x813A,
	TEXTURE_WRAP_R                   = 0x8072,
	UNPACK_IMAGE_HEIGHT              = 0x806E,
	UNPACK_SKIP_IMAGES               = 0x806D,
	UNSIGNED_BYTE_2_3_3_REV          = 0x8362,
	UNSIGNED_BYTE_3_3_2              = 0x8032,
	UNSIGNED_INT_10_10_10_2          = 0x8036,
	UNSIGNED_INT_2_10_10_10_REV      = 0x8368,
	UNSIGNED_INT_8_8_8_8             = 0x8035,
	UNSIGNED_INT_8_8_8_8_REV         = 0x8367,
	UNSIGNED_SHORT_1_5_5_5_REV       = 0x8366,
	UNSIGNED_SHORT_4_4_4_4           = 0x8033,
	UNSIGNED_SHORT_4_4_4_4_REV       = 0x8365,
	UNSIGNED_SHORT_5_5_5_1           = 0x8034,
	UNSIGNED_SHORT_5_6_5             = 0x8363,
	UNSIGNED_SHORT_5_6_5_REV         = 0x8364,
	
	/* gl version 1.3 */
	ACTIVE_TEXTURE                   = 0x84E0,
	CLAMP_TO_BORDER                  = 0x812D,
	COMPRESSED_RGB                   = 0x84ED,
	COMPRESSED_RGBA                  = 0x84EE,
	COMPRESSED_TEXTURE_FORMATS       = 0x86A3,
	MAX_CUBE_MAP_TEXTURE_SIZE        = 0x851C,
	MULTISAMPLE                      = 0x809D,
	NUM_COMPRESSED_TEXTURE_FORMATS   = 0x86A2,
	PROXY_TEXTURE_CUBE_MAP           = 0x851B,
	SAMPLES                          = 0x80A9,
	SAMPLE_ALPHA_TO_COVERAGE         = 0x809E,
	SAMPLE_ALPHA_TO_ONE              = 0x809F,
	SAMPLE_BUFFERS                   = 0x80A8,
	SAMPLE_COVERAGE                  = 0x80A0,
	SAMPLE_COVERAGE_INVERT           = 0x80AB,
	SAMPLE_COVERAGE_VALUE            = 0x80AA,
	TEXTURE0                         = 0x84C0,
	TEXTURE1                         = 0x84C1,
	TEXTURE10                        = 0x84CA,
	TEXTURE11                        = 0x84CB,
	TEXTURE12                        = 0x84CC,
	TEXTURE13                        = 0x84CD,
	TEXTURE14                        = 0x84CE,
	TEXTURE15                        = 0x84CF,
	TEXTURE16                        = 0x84D0,
	TEXTURE17                        = 0x84D1,
	TEXTURE18                        = 0x84D2,
	TEXTURE19                        = 0x84D3,
	TEXTURE2                         = 0x84C2,
	TEXTURE20                        = 0x84D4,
	TEXTURE21                        = 0x84D5,
	TEXTURE22                        = 0x84D6,
	TEXTURE23                        = 0x84D7,
	TEXTURE24                        = 0x84D8,
	TEXTURE25                        = 0x84D9,
	TEXTURE26                        = 0x84DA,
	TEXTURE27                        = 0x84DB,
	TEXTURE28                        = 0x84DC,
	TEXTURE29                        = 0x84DD,
	TEXTURE3                         = 0x84C3,
	TEXTURE30                        = 0x84DE,
	TEXTURE31                        = 0x84DF,
	TEXTURE4                         = 0x84C4,
	TEXTURE5                         = 0x84C5,
	TEXTURE6                         = 0x84C6,
	TEXTURE7                         = 0x84C7,
	TEXTURE8                         = 0x84C8,
	TEXTURE9                         = 0x84C9,
	TEXTURE_BINDING_CUBE_MAP         = 0x8514,
	TEXTURE_COMPRESSED               = 0x86A1,
	TEXTURE_COMPRESSED_IMAGE_SIZE    = 0x86A0,
	TEXTURE_COMPRESSION_HINT         = 0x84EF,
	TEXTURE_CUBE_MAP                 = 0x8513,
	TEXTURE_CUBE_MAP_NEGATIVE_X      = 0x8516,
	TEXTURE_CUBE_MAP_NEGATIVE_Y      = 0x8518,
	TEXTURE_CUBE_MAP_NEGATIVE_Z      = 0x851A,
	TEXTURE_CUBE_MAP_POSITIVE_X      = 0x8515,
	TEXTURE_CUBE_MAP_POSITIVE_Y      = 0x8517,
	TEXTURE_CUBE_MAP_POSITIVE_Z      = 0x8519,
	
	/* gl version 1.4 */
	BLEND_COLOR                      = 0x8005,
	BLEND_DST_ALPHA                  = 0x80CA,
	BLEND_DST_RGB                    = 0x80C8,
	BLEND_SRC_ALPHA                  = 0x80CB,
	BLEND_SRC_RGB                    = 0x80C9,
	CONSTANT_ALPHA                   = 0x8003,
	CONSTANT_COLOR                   = 0x8001,
	DECR_WRAP                        = 0x8508,
	DEPTH_COMPONENT16                = 0x81A5,
	DEPTH_COMPONENT24                = 0x81A6,
	DEPTH_COMPONENT32                = 0x81A7,
	FUNC_ADD                         = 0x8006,
	FUNC_REVERSE_SUBTRACT            = 0x800B,
	FUNC_SUBTRACT                    = 0x800A,
	INCR_WRAP                        = 0x8507,
	MAX                              = 0x8008,
	MAX_TEXTURE_LOD_BIAS             = 0x84FD,
	MIN                              = 0x8007,
	MIRRORED_REPEAT                  = 0x8370,
	ONE_MINUS_CONSTANT_ALPHA         = 0x8004,
	ONE_MINUS_CONSTANT_COLOR         = 0x8002,
	POINT_FADE_THRESHOLD_SIZE        = 0x8128,
	TEXTURE_COMPARE_FUNC             = 0x884D,
	TEXTURE_COMPARE_MODE             = 0x884C,
	TEXTURE_DEPTH_SIZE               = 0x884A,
	TEXTURE_LOD_BIAS                 = 0x8501,
	
	/* gl version 1.5 */
	ARRAY_BUFFER                     = 0x8892,
	ARRAY_BUFFER_BINDING             = 0x8894,
	BUFFER_ACCESS                    = 0x88BB,
	BUFFER_MAPPED                    = 0x88BC,
	BUFFER_MAP_POINTER               = 0x88BD,
	BUFFER_SIZE                      = 0x8764,
	BUFFER_USAGE                     = 0x8765,
	CURRENT_QUERY                    = 0x8865,
	DYNAMIC_COPY                     = 0x88EA,
	DYNAMIC_DRAW                     = 0x88E8,
	DYNAMIC_READ                     = 0x88E9,
	ELEMENT_ARRAY_BUFFER             = 0x8893,
	ELEMENT_ARRAY_BUFFER_BINDING     = 0x8895,
	QUERY_COUNTER_BITS               = 0x8864,
	QUERY_RESULT                     = 0x8866,
	QUERY_RESULT_AVAILABLE           = 0x8867,
	READ_ONLY                        = 0x88B8,
	READ_WRITE                       = 0x88BA,
	SAMPLES_PASSED                   = 0x8914,
	SRC1_ALPHA                       = 0x8589,
	STATIC_COPY                      = 0x88E6,
	STATIC_DRAW                      = 0x88E4,
	STATIC_READ                      = 0x88E5,
	STREAM_COPY                      = 0x88E2,
	STREAM_DRAW                      = 0x88E0,
	STREAM_READ                      = 0x88E1,
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F,
	WRITE_ONLY                       = 0x88B9,
	
	/* gl version 2.0 */
	ACTIVE_ATTRIBUTES                = 0x8B89,
	ACTIVE_ATTRIBUTE_MAX_LENGTH      = 0x8B8A,
	ACTIVE_UNIFORMS                  = 0x8B86,
	ACTIVE_UNIFORM_MAX_LENGTH        = 0x8B87,
	ATTACHED_SHADERS                 = 0x8B85,
	BLEND_EQUATION_ALPHA             = 0x883D,
	BLEND_EQUATION_RGB               = 0x8009,
	BOOL                             = 0x8B56,
	BOOL_VEC2                        = 0x8B57,
	BOOL_VEC3                        = 0x8B58,
	BOOL_VEC4                        = 0x8B59,
	COMPILE_STATUS                   = 0x8B81,
	CURRENT_PROGRAM                  = 0x8B8D,
	CURRENT_VERTEX_ATTRIB            = 0x8626,
	DELETE_STATUS                    = 0x8B80,
	DRAW_BUFFER0                     = 0x8825,
	DRAW_BUFFER1                     = 0x8826,
	DRAW_BUFFER10                    = 0x882F,
	DRAW_BUFFER11                    = 0x8830,
	DRAW_BUFFER12                    = 0x8831,
	DRAW_BUFFER13                    = 0x8832,
	DRAW_BUFFER14                    = 0x8833,
	DRAW_BUFFER15                    = 0x8834,
	DRAW_BUFFER2                     = 0x8827,
	DRAW_BUFFER3                     = 0x8828,
	DRAW_BUFFER4                     = 0x8829,
	DRAW_BUFFER5                     = 0x882A,
	DRAW_BUFFER6                     = 0x882B,
	DRAW_BUFFER7                     = 0x882C,
	DRAW_BUFFER8                     = 0x882D,
	DRAW_BUFFER9                     = 0x882E,
	FLOAT_MAT2                       = 0x8B5A,
	FLOAT_MAT3                       = 0x8B5B,
	FLOAT_MAT4                       = 0x8B5C,
	FLOAT_VEC2                       = 0x8B50,
	FLOAT_VEC3                       = 0x8B51,
	FLOAT_VEC4                       = 0x8B52,
	FRAGMENT_SHADER                  = 0x8B30,
	FRAGMENT_SHADER_DERIVATIVE_HINT  = 0x8B8B,
	INFO_LOG_LENGTH                  = 0x8B84,
	INT_VEC2                         = 0x8B53,
	INT_VEC3                         = 0x8B54,
	INT_VEC4                         = 0x8B55,
	LINK_STATUS                      = 0x8B82,
	LOWER_LEFT                       = 0x8CA1,
	MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D,
	MAX_DRAW_BUFFERS                 = 0x8824,
	MAX_FRAGMENT_UNIFORM_COMPONENTS  = 0x8B49,
	MAX_TEXTURE_IMAGE_UNITS          = 0x8872,
	MAX_VARYING_FLOATS               = 0x8B4B,
	MAX_VERTEX_ATTRIBS               = 0x8869,
	MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C,
	MAX_VERTEX_UNIFORM_COMPONENTS    = 0x8B4A,
	POINT_SPRITE_COORD_ORIGIN        = 0x8CA0,
	SAMPLER_1D                       = 0x8B5D,
	SAMPLER_1D_SHADOW                = 0x8B61,
	SAMPLER_2D                       = 0x8B5E,
	SAMPLER_2D_SHADOW                = 0x8B62,
	SAMPLER_3D                       = 0x8B5F,
	SAMPLER_CUBE                     = 0x8B60,
	SHADER_SOURCE_LENGTH             = 0x8B88,
	SHADER_TYPE                      = 0x8B4F,
	SHADING_LANGUAGE_VERSION         = 0x8B8C,
	STENCIL_BACK_FAIL                = 0x8801,
	STENCIL_BACK_FUNC                = 0x8800,
	STENCIL_BACK_PASS_DEPTH_FAIL     = 0x8802,
	STENCIL_BACK_PASS_DEPTH_PASS     = 0x8803,
	STENCIL_BACK_REF                 = 0x8CA3,
	STENCIL_BACK_VALUE_MASK          = 0x8CA4,
	STENCIL_BACK_WRITEMASK           = 0x8CA5,
	UPPER_LEFT                       = 0x8CA2,
	VALIDATE_STATUS                  = 0x8B83,
	VERTEX_ATTRIB_ARRAY_ENABLED      = 0x8622,
	VERTEX_ATTRIB_ARRAY_NORMALIZED   = 0x886A,
	VERTEX_ATTRIB_ARRAY_POINTER      = 0x8645,
	VERTEX_ATTRIB_ARRAY_SIZE         = 0x8623,
	VERTEX_ATTRIB_ARRAY_STRIDE       = 0x8624,
	VERTEX_ATTRIB_ARRAY_TYPE         = 0x8625,
	VERTEX_PROGRAM_POINT_SIZE        = 0x8642,
	VERTEX_SHADER                    = 0x8B31,
	
	/* gl version 2.1 */
	COMPRESSED_SRGB                  = 0x8C48,
	COMPRESSED_SRGB_ALPHA            = 0x8C49,
	FLOAT_MAT2x3                     = 0x8B65,
	FLOAT_MAT2x4                     = 0x8B66,
	FLOAT_MAT3x2                     = 0x8B67,
	FLOAT_MAT3x4                     = 0x8B68,
	FLOAT_MAT4x2                     = 0x8B69,
	FLOAT_MAT4x3                     = 0x8B6A,
	PIXEL_PACK_BUFFER                = 0x88EB,
	PIXEL_PACK_BUFFER_BINDING        = 0x88ED,
	PIXEL_UNPACK_BUFFER              = 0x88EC,
	PIXEL_UNPACK_BUFFER_BINDING      = 0x88EF,
	SRGB                             = 0x8C40,
	SRGB8                            = 0x8C41,
	SRGB8_ALPHA8                     = 0x8C43,
	SRGB_ALPHA                       = 0x8C42,
	
	/* gl version 3.0 */
	BGRA_INTEGER                     = 0x8D9B,
	BGR_INTEGER                      = 0x8D9A,
	BLUE_INTEGER                     = 0x8D96,
	BUFFER_ACCESS_FLAGS              = 0x911F,
	BUFFER_MAP_LENGTH                = 0x9120,
	BUFFER_MAP_OFFSET                = 0x9121,
	CLAMP_READ_COLOR                 = 0x891C,
	CLIP_DISTANCE0                   = 0x3000,
	CLIP_DISTANCE1                   = 0x3001,
	CLIP_DISTANCE2                   = 0x3002,
	CLIP_DISTANCE3                   = 0x3003,
	CLIP_DISTANCE4                   = 0x3004,
	CLIP_DISTANCE5                   = 0x3005,
	CLIP_DISTANCE6                   = 0x3006,
	CLIP_DISTANCE7                   = 0x3007,
	COLOR_ATTACHMENT0                = 0x8CE0,
	COLOR_ATTACHMENT1                = 0x8CE1,
	COLOR_ATTACHMENT10               = 0x8CEA,
	COLOR_ATTACHMENT11               = 0x8CEB,
	COLOR_ATTACHMENT12               = 0x8CEC,
	COLOR_ATTACHMENT13               = 0x8CED,
	COLOR_ATTACHMENT14               = 0x8CEE,
	COLOR_ATTACHMENT15               = 0x8CEF,
	COLOR_ATTACHMENT16               = 0x8CF0,
	COLOR_ATTACHMENT17               = 0x8CF1,
	COLOR_ATTACHMENT18               = 0x8CF2,
	COLOR_ATTACHMENT19               = 0x8CF3,
	COLOR_ATTACHMENT2                = 0x8CE2,
	COLOR_ATTACHMENT20               = 0x8CF4,
	COLOR_ATTACHMENT21               = 0x8CF5,
	COLOR_ATTACHMENT22               = 0x8CF6,
	COLOR_ATTACHMENT23               = 0x8CF7,
	COLOR_ATTACHMENT24               = 0x8CF8,
	COLOR_ATTACHMENT25               = 0x8CF9,
	COLOR_ATTACHMENT26               = 0x8CFA,
	COLOR_ATTACHMENT27               = 0x8CFB,
	COLOR_ATTACHMENT28               = 0x8CFC,
	COLOR_ATTACHMENT29               = 0x8CFD,
	COLOR_ATTACHMENT3                = 0x8CE3,
	COLOR_ATTACHMENT30               = 0x8CFE,
	COLOR_ATTACHMENT31               = 0x8CFF,
	COLOR_ATTACHMENT4                = 0x8CE4,
	COLOR_ATTACHMENT5                = 0x8CE5,
	COLOR_ATTACHMENT6                = 0x8CE6,
	COLOR_ATTACHMENT7                = 0x8CE7,
	COLOR_ATTACHMENT8                = 0x8CE8,
	COLOR_ATTACHMENT9                = 0x8CE9,
	COMPARE_REF_TO_TEXTURE           = 0x884E,
	COMPRESSED_RED                   = 0x8225,
	COMPRESSED_RED_RGTC1             = 0x8DBB,
	COMPRESSED_RG                    = 0x8226,
	COMPRESSED_RG_RGTC2              = 0x8DBD,
	COMPRESSED_SIGNED_RED_RGTC1      = 0x8DBC,
	COMPRESSED_SIGNED_RG_RGTC2       = 0x8DBE,
	CONTEXT_FLAGS                    = 0x821E,
	CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001,
	DEPTH24_STENCIL8                 = 0x88F0,
	DEPTH32F_STENCIL8                = 0x8CAD,
	DEPTH_ATTACHMENT                 = 0x8D00,
	DEPTH_COMPONENT32F               = 0x8CAC,
	DEPTH_STENCIL                    = 0x84F9,
	DEPTH_STENCIL_ATTACHMENT         = 0x821A,
	DRAW_FRAMEBUFFER                 = 0x8CA9,
	DRAW_FRAMEBUFFER_BINDING         = 0x8CA6,
	FIXED_ONLY                       = 0x891D,
	FLOAT_32_UNSIGNED_INT_24_8_REV   = 0x8DAD,
	FRAMEBUFFER                      = 0x8D40,
	FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215,
	FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214,
	FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210,
	FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211,
	FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216,
	FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213,
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1,
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0,
	FRAMEBUFFER_ATTACHMENT_RED_SIZE  = 0x8212,
	FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2,
	FRAMEBUFFER_BINDING              = 0x8CA6,
	FRAMEBUFFER_COMPLETE             = 0x8CD5,
	FRAMEBUFFER_DEFAULT              = 0x8218,
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6,
	FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB,
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7,
	FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56,
	FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC,
	FRAMEBUFFER_SRGB                 = 0x8DB9,
	FRAMEBUFFER_UNDEFINED            = 0x8219,
	FRAMEBUFFER_UNSUPPORTED          = 0x8CDD,
	GREEN_INTEGER                    = 0x8D95,
	HALF_FLOAT                       = 0x140B,
	INTERLEAVED_ATTRIBS              = 0x8C8C,
	INT_SAMPLER_1D                   = 0x8DC9,
	INT_SAMPLER_1D_ARRAY             = 0x8DCE,
	INT_SAMPLER_2D                   = 0x8DCA,
	INT_SAMPLER_2D_ARRAY             = 0x8DCF,
	INT_SAMPLER_3D                   = 0x8DCB,
	INT_SAMPLER_CUBE                 = 0x8DCC,
	INVALID_FRAMEBUFFER_OPERATION    = 0x0506,
	MAJOR_VERSION                    = 0x821B,
	MAP_FLUSH_EXPLICIT_BIT           = 0x0010,
	MAP_INVALIDATE_BUFFER_BIT        = 0x0008,
	MAP_INVALIDATE_RANGE_BIT         = 0x0004,
	MAP_READ_BIT                     = 0x0001,
	MAP_UNSYNCHRONIZED_BIT           = 0x0020,
	MAP_WRITE_BIT                    = 0x0002,
	MAX_ARRAY_TEXTURE_LAYERS         = 0x88FF,
	MAX_CLIP_DISTANCES               = 0x0D32,
	MAX_COLOR_ATTACHMENTS            = 0x8CDF,
	MAX_PROGRAM_TEXEL_OFFSET         = 0x8905,
	MAX_RENDERBUFFER_SIZE            = 0x84E8,
	MAX_SAMPLES                      = 0x8D57,
	MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A,
	MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B,
	MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80,
	MAX_VARYING_COMPONENTS           = 0x8B4B,
	MINOR_VERSION                    = 0x821C,
	MIN_PROGRAM_TEXEL_OFFSET         = 0x8904,
	NUM_EXTENSIONS                   = 0x821D,
	PRIMITIVES_GENERATED             = 0x8C87,
	PROXY_TEXTURE_1D_ARRAY           = 0x8C19,
	PROXY_TEXTURE_2D_ARRAY           = 0x8C1B,
	QUERY_BY_REGION_NO_WAIT          = 0x8E16,
	QUERY_BY_REGION_WAIT             = 0x8E15,
	QUERY_NO_WAIT                    = 0x8E14,
	QUERY_WAIT                       = 0x8E13,
	R11F_G11F_B10F                   = 0x8C3A,
	R16                              = 0x822A,
	R16F                             = 0x822D,
	R16I                             = 0x8233,
	R16UI                            = 0x8234,
	R32F                             = 0x822E,
	R32I                             = 0x8235,
	R32UI                            = 0x8236,
	R8                               = 0x8229,
	R8I                              = 0x8231,
	R8UI                             = 0x8232,
	RASTERIZER_DISCARD               = 0x8C89,
	READ_FRAMEBUFFER                 = 0x8CA8,
	READ_FRAMEBUFFER_BINDING         = 0x8CAA,
	RED_INTEGER                      = 0x8D94,
	RENDERBUFFER                     = 0x8D41,
	RENDERBUFFER_ALPHA_SIZE          = 0x8D53,
	RENDERBUFFER_BINDING             = 0x8CA7,
	RENDERBUFFER_BLUE_SIZE           = 0x8D52,
	RENDERBUFFER_DEPTH_SIZE          = 0x8D54,
	RENDERBUFFER_GREEN_SIZE          = 0x8D51,
	RENDERBUFFER_HEIGHT              = 0x8D43,
	RENDERBUFFER_INTERNAL_FORMAT     = 0x8D44,
	RENDERBUFFER_RED_SIZE            = 0x8D50,
	RENDERBUFFER_SAMPLES             = 0x8CAB,
	RENDERBUFFER_STENCIL_SIZE        = 0x8D55,
	RENDERBUFFER_WIDTH               = 0x8D42,
	RG                               = 0x8227,
	RG16                             = 0x822C,
	RG16F                            = 0x822F,
	RG16I                            = 0x8239,
	RG16UI                           = 0x823A,
	RG32F                            = 0x8230,
	RG32I                            = 0x823B,
	RG32UI                           = 0x823C,
	RG8                              = 0x822B,
	RG8I                             = 0x8237,
	RG8UI                            = 0x8238,
	RGB16F                           = 0x881B,
	RGB16I                           = 0x8D89,
	RGB16UI                          = 0x8D77,
	RGB32F                           = 0x8815,
	RGB32I                           = 0x8D83,
	RGB32UI                          = 0x8D71,
	RGB8I                            = 0x8D8F,
	RGB8UI                           = 0x8D7D,
	RGB9_E5                          = 0x8C3D,
	RGBA16F                          = 0x881A,
	RGBA16I                          = 0x8D88,
	RGBA16UI                         = 0x8D76,
	RGBA32F                          = 0x8814,
	RGBA32I                          = 0x8D82,
	RGBA32UI                         = 0x8D70,
	RGBA8I                           = 0x8D8E,
	RGBA8UI                          = 0x8D7C,
	RGBA_INTEGER                     = 0x8D99,
	RGB_INTEGER                      = 0x8D98,
	RG_INTEGER                       = 0x8228,
	SAMPLER_1D_ARRAY                 = 0x8DC0,
	SAMPLER_1D_ARRAY_SHADOW          = 0x8DC3,
	SAMPLER_2D_ARRAY                 = 0x8DC1,
	SAMPLER_2D_ARRAY_SHADOW          = 0x8DC4,
	SAMPLER_CUBE_SHADOW              = 0x8DC5,
	SEPARATE_ATTRIBS                 = 0x8C8D,
	STENCIL_ATTACHMENT               = 0x8D20,
	STENCIL_INDEX1                   = 0x8D46,
	STENCIL_INDEX16                  = 0x8D49,
	STENCIL_INDEX4                   = 0x8D47,
	STENCIL_INDEX8                   = 0x8D48,
	TEXTURE_1D_ARRAY                 = 0x8C18,
	TEXTURE_2D_ARRAY                 = 0x8C1A,
	TEXTURE_ALPHA_TYPE               = 0x8C13,
	TEXTURE_BINDING_1D_ARRAY         = 0x8C1C,
	TEXTURE_BINDING_2D_ARRAY         = 0x8C1D,
	TEXTURE_BLUE_TYPE                = 0x8C12,
	TEXTURE_DEPTH_TYPE               = 0x8C16,
	TEXTURE_GREEN_TYPE               = 0x8C11,
	TEXTURE_RED_TYPE                 = 0x8C10,
	TEXTURE_SHARED_SIZE              = 0x8C3F,
	TEXTURE_STENCIL_SIZE             = 0x88F1,
	TRANSFORM_FEEDBACK_BUFFER        = 0x8C8E,
	TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F,
	TRANSFORM_FEEDBACK_BUFFER_MODE   = 0x8C7F,
	TRANSFORM_FEEDBACK_BUFFER_SIZE   = 0x8C85,
	TRANSFORM_FEEDBACK_BUFFER_START  = 0x8C84,
	TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88,
	TRANSFORM_FEEDBACK_VARYINGS      = 0x8C83,
	TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76,
	UNSIGNED_INT_10F_11F_11F_REV     = 0x8C3B,
	UNSIGNED_INT_24_8                = 0x84FA,
	UNSIGNED_INT_5_9_9_9_REV         = 0x8C3E,
	UNSIGNED_INT_SAMPLER_1D          = 0x8DD1,
	UNSIGNED_INT_SAMPLER_1D_ARRAY    = 0x8DD6,
	UNSIGNED_INT_SAMPLER_2D          = 0x8DD2,
	UNSIGNED_INT_SAMPLER_2D_ARRAY    = 0x8DD7,
	UNSIGNED_INT_SAMPLER_3D          = 0x8DD3,
	UNSIGNED_INT_SAMPLER_CUBE        = 0x8DD4,
	UNSIGNED_INT_VEC2                = 0x8DC6,
	UNSIGNED_INT_VEC3                = 0x8DC7,
	UNSIGNED_INT_VEC4                = 0x8DC8,
	UNSIGNED_NORMALIZED              = 0x8C17,
	VERTEX_ARRAY_BINDING             = 0x85B5,
	VERTEX_ATTRIB_ARRAY_INTEGER      = 0x88FD,
	
	/* gl version 3.1 */
	ACTIVE_UNIFORM_BLOCKS            = 0x8A36,
	ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35,
	COPY_READ_BUFFER                 = 0x8F36,
	COPY_WRITE_BUFFER                = 0x8F37,
	INT_SAMPLER_2D_RECT              = 0x8DCD,
	INT_SAMPLER_BUFFER               = 0x8DD0,
	INVALID_INDEX                    = 0xFFFFFFFF,
	MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33,
	MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32,
	MAX_COMBINED_UNIFORM_BLOCKS      = 0x8A2E,
	MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31,
	MAX_FRAGMENT_UNIFORM_BLOCKS      = 0x8A2D,
	MAX_GEOMETRY_UNIFORM_BLOCKS      = 0x8A2C,
	MAX_RECTANGLE_TEXTURE_SIZE       = 0x84F8,
	MAX_TEXTURE_BUFFER_SIZE          = 0x8C2B,
	MAX_UNIFORM_BLOCK_SIZE           = 0x8A30,
	MAX_UNIFORM_BUFFER_BINDINGS      = 0x8A2F,
	MAX_VERTEX_UNIFORM_BLOCKS        = 0x8A2B,
	PRIMITIVE_RESTART                = 0x8F9D,
	PRIMITIVE_RESTART_INDEX          = 0x8F9E,
	PROXY_TEXTURE_RECTANGLE          = 0x84F7,
	R16_SNORM                        = 0x8F98,
	R8_SNORM                         = 0x8F94,
	RG16_SNORM                       = 0x8F99,
	RG8_SNORM                        = 0x8F95,
	RGB16_SNORM                      = 0x8F9A,
	RGB8_SNORM                       = 0x8F96,
	RGBA16_SNORM                     = 0x8F9B,
	RGBA8_SNORM                      = 0x8F97,
	SAMPLER_2D_RECT                  = 0x8B63,
	SAMPLER_2D_RECT_SHADOW           = 0x8B64,
	SAMPLER_BUFFER                   = 0x8DC2,
	SIGNED_NORMALIZED                = 0x8F9C,
	TEXTURE_BINDING_BUFFER           = 0x8C2C,
	TEXTURE_BINDING_RECTANGLE        = 0x84F6,
	TEXTURE_BUFFER                   = 0x8C2A,
	TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D,
	TEXTURE_RECTANGLE                = 0x84F5,
	UNIFORM_ARRAY_STRIDE             = 0x8A3C,
	UNIFORM_BLOCK_ACTIVE_UNIFORMS    = 0x8A42,
	UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43,
	UNIFORM_BLOCK_BINDING            = 0x8A3F,
	UNIFORM_BLOCK_DATA_SIZE          = 0x8A40,
	UNIFORM_BLOCK_INDEX              = 0x8A3A,
	UNIFORM_BLOCK_NAME_LENGTH        = 0x8A41,
	UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46,
	UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45,
	UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44,
	UNIFORM_BUFFER                   = 0x8A11,
	UNIFORM_BUFFER_BINDING           = 0x8A28,
	UNIFORM_BUFFER_OFFSET_ALIGNMENT  = 0x8A34,
	UNIFORM_BUFFER_SIZE              = 0x8A2A,
	UNIFORM_BUFFER_START             = 0x8A29,
	UNIFORM_IS_ROW_MAJOR             = 0x8A3E,
	UNIFORM_MATRIX_STRIDE            = 0x8A3D,
	UNIFORM_NAME_LENGTH              = 0x8A39,
	UNIFORM_OFFSET                   = 0x8A3B,
	UNIFORM_SIZE                     = 0x8A38,
	UNIFORM_TYPE                     = 0x8A37,
	UNSIGNED_INT_SAMPLER_2D_RECT     = 0x8DD5,
	UNSIGNED_INT_SAMPLER_BUFFER      = 0x8DD8,
	
	/* gl version 3.2 */
	ALREADY_SIGNALED                 = 0x911A,
	CONDITION_SATISFIED              = 0x911C,
	CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002,
	CONTEXT_CORE_PROFILE_BIT         = 0x00000001,
	CONTEXT_PROFILE_MASK             = 0x9126,
	DEPTH_CLAMP                      = 0x864F,
	FIRST_VERTEX_CONVENTION          = 0x8E4D,
	FRAMEBUFFER_ATTACHMENT_LAYERED   = 0x8DA7,
	FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8,
	GEOMETRY_INPUT_TYPE              = 0x8917,
	GEOMETRY_OUTPUT_TYPE             = 0x8918,
	GEOMETRY_SHADER                  = 0x8DD9,
	GEOMETRY_VERTICES_OUT            = 0x8916,
	INT_SAMPLER_2D_MULTISAMPLE       = 0x9109,
	INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C,
	LAST_VERTEX_CONVENTION           = 0x8E4E,
	LINES_ADJACENCY                  = 0x000A,
	LINE_STRIP_ADJACENCY             = 0x000B,
	MAX_COLOR_TEXTURE_SAMPLES        = 0x910E,
	MAX_DEPTH_TEXTURE_SAMPLES        = 0x910F,
	MAX_FRAGMENT_INPUT_COMPONENTS    = 0x9125,
	MAX_GEOMETRY_INPUT_COMPONENTS    = 0x9123,
	MAX_GEOMETRY_OUTPUT_COMPONENTS   = 0x9124,
	MAX_GEOMETRY_OUTPUT_VERTICES     = 0x8DE0,
	MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29,
	MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1,
	MAX_GEOMETRY_UNIFORM_COMPONENTS  = 0x8DDF,
	MAX_INTEGER_SAMPLES              = 0x9110,
	MAX_SAMPLE_MASK_WORDS            = 0x8E59,
	MAX_SERVER_WAIT_TIMEOUT          = 0x9111,
	MAX_VERTEX_OUTPUT_COMPONENTS     = 0x9122,
	OBJECT_TYPE                      = 0x9112,
	PROGRAM_POINT_SIZE               = 0x8642,
	PROVOKING_VERTEX                 = 0x8E4F,
	PROXY_TEXTURE_2D_MULTISAMPLE     = 0x9101,
	PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103,
	QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C,
	SAMPLER_2D_MULTISAMPLE           = 0x9108,
	SAMPLER_2D_MULTISAMPLE_ARRAY     = 0x910B,
	SAMPLE_MASK                      = 0x8E51,
	SAMPLE_MASK_VALUE                = 0x8E52,
	SAMPLE_POSITION                  = 0x8E50,
	SIGNALED                         = 0x9119,
	SYNC_CONDITION                   = 0x9113,
	SYNC_FENCE                       = 0x9116,
	SYNC_FLAGS                       = 0x9115,
	SYNC_FLUSH_COMMANDS_BIT          = 0x00000001,
	SYNC_GPU_COMMANDS_COMPLETE       = 0x9117,
	SYNC_STATUS                      = 0x9114,
	TEXTURE_2D_MULTISAMPLE           = 0x9100,
	TEXTURE_2D_MULTISAMPLE_ARRAY     = 0x9102,
	TEXTURE_BINDING_2D_MULTISAMPLE   = 0x9104,
	TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105,
	TEXTURE_CUBE_MAP_SEAMLESS        = 0x884F,
	TEXTURE_FIXED_SAMPLE_LOCATIONS   = 0x9107,
	TEXTURE_SAMPLES                  = 0x9106,
	TIMEOUT_EXPIRED                  = 0x911B,
	TIMEOUT_IGNORED                  = 0xFFFFFFFFFFFFFFFF,
	TRIANGLES_ADJACENCY              = 0x000C,
	TRIANGLE_STRIP_ADJACENCY         = 0x000D,
	UNSIGNALED                       = 0x9118,
	UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A,
	UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D,
	WAIT_FAILED_                     = 0x911D,
	
	/* gl version 3.3 */
	ANY_SAMPLES_PASSED               = 0x8C2F,
	INT_2_10_10_10_REV               = 0x8D9F,
	MAX_DUAL_SOURCE_DRAW_BUFFERS     = 0x88FC,
	ONE_MINUS_SRC1_ALPHA             = 0x88FB,
	ONE_MINUS_SRC1_COLOR             = 0x88FA,
	RGB10_A2UI                       = 0x906F,
	SAMPLER_BINDING                  = 0x8919,
	SRC1_COLOR                       = 0x88F9,
	TEXTURE_SWIZZLE_A                = 0x8E45,
	TEXTURE_SWIZZLE_B                = 0x8E44,
	TEXTURE_SWIZZLE_G                = 0x8E43,
	TEXTURE_SWIZZLE_R                = 0x8E42,
	TEXTURE_SWIZZLE_RGBA             = 0x8E46,
	TIMESTAMP                        = 0x8E28,
	TIME_ELAPSED                     = 0x88BF,
	VERTEX_ATTRIB_ARRAY_DIVISOR      = 0x88FE,
	
};

namespace _impl {
/* gl version 1.0 */
extern void (AWGL_API* BlendFunc)(GLenum sfactor, GLenum dfactor);
extern void (AWGL_API* Clear)(GLbitfield mask);
extern void (AWGL_API* ClearColor)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void (AWGL_API* ClearDepth)(GLdouble depth);
extern void (AWGL_API* ClearStencil)(GLint s);
extern void (AWGL_API* ColorMask)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void (AWGL_API* CullFace)(GLenum mode);
extern void (AWGL_API* DepthFunc)(GLenum func);
extern void (AWGL_API* DepthMask)(GLboolean flag);
extern void (AWGL_API* DepthRange)(GLdouble ren_near, GLdouble ren_far);
extern void (AWGL_API* Disable)(GLenum cap);
extern void (AWGL_API* DrawBuffer)(GLenum buf);
extern void (AWGL_API* Enable)(GLenum cap);
extern void (AWGL_API* Finish)(void);
extern void (AWGL_API* Flush)(void);
extern void (AWGL_API* FrontFace)(GLenum mode);
extern void (AWGL_API* GetBooleanv)(GLenum pname, GLboolean * data);
extern void (AWGL_API* GetDoublev)(GLenum pname, GLdouble * data);
extern GLenum (AWGL_API* GetError)(void);
extern void (AWGL_API* GetFloatv)(GLenum pname, GLfloat * data);
extern void (AWGL_API* GetIntegerv)(GLenum pname, GLint * data);
extern const GLubyte * (AWGL_API* GetString)(GLenum name);
extern void (AWGL_API* GetTexImage)(GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
extern void (AWGL_API* GetTexLevelParameterfv)(GLenum target, GLint level, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetTexLevelParameteriv)(GLenum target, GLint level, GLenum pname, GLint * params);
extern void (AWGL_API* GetTexParameterfv)(GLenum target, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetTexParameteriv)(GLenum target, GLenum pname, GLint * params);
extern void (AWGL_API* Hint)(GLenum target, GLenum mode);
extern GLboolean (AWGL_API* IsEnabled)(GLenum cap);
extern void (AWGL_API* LineWidth)(GLfloat width);
extern void (AWGL_API* LogicOp)(GLenum opcode);
extern void (AWGL_API* PixelStoref)(GLenum pname, GLfloat param);
extern void (AWGL_API* PixelStorei)(GLenum pname, GLint param);
extern void (AWGL_API* PointSize)(GLfloat size);
extern void (AWGL_API* PolygonMode)(GLenum face, GLenum mode);
extern void (AWGL_API* ReadBuffer)(GLenum src);
extern void (AWGL_API* ReadPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels);
extern void (AWGL_API* Scissor)(GLint x, GLint y, GLsizei width, GLsizei height);
extern void (AWGL_API* StencilFunc)(GLenum func, GLint ref, GLuint mask);
extern void (AWGL_API* StencilMask)(GLuint mask);
extern void (AWGL_API* StencilOp)(GLenum fail, GLenum zfail, GLenum zpass);
extern void (AWGL_API* TexImage1D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexImage2D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexParameterf)(GLenum target, GLenum pname, GLfloat param);
extern void (AWGL_API* TexParameterfv)(GLenum target, GLenum pname, const GLfloat * params);
extern void (AWGL_API* TexParameteri)(GLenum target, GLenum pname, GLint param);
extern void (AWGL_API* TexParameteriv)(GLenum target, GLenum pname, const GLint * params);
extern void (AWGL_API* Viewport)(GLint x, GLint y, GLsizei width, GLsizei height);

/* gl version 1.1 */
extern void (AWGL_API* BindTexture)(GLenum target, GLuint texture);
extern void (AWGL_API* CopyTexImage1D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void (AWGL_API* CopyTexImage2D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void (AWGL_API* CopyTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void (AWGL_API* CopyTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void (AWGL_API* DeleteTextures)(GLsizei n, const GLuint * textures);
extern void (AWGL_API* DrawArrays)(GLenum mode, GLint first, GLsizei count);
extern void (AWGL_API* DrawElements)(GLenum mode, GLsizei count, GLenum type, const void * indices);
extern void (AWGL_API* GenTextures)(GLsizei n, GLuint * textures);
extern GLboolean (AWGL_API* IsTexture)(GLuint texture);
extern void (AWGL_API* PolygonOffset)(GLfloat factor, GLfloat units);
extern void (AWGL_API* TexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);

/* gl version 1.2 */
extern void (AWGL_API* CopyTexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void (AWGL_API* DrawRangeElements)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
extern void (AWGL_API* TexImage3D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);

/* gl version 1.3 */
extern void (AWGL_API* ActiveTexture)(GLenum texture);
extern void (AWGL_API* CompressedTexImage1D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexImage2D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexImage3D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
extern void (AWGL_API* GetCompressedTexImage)(GLenum target, GLint level, void * img);
extern void (AWGL_API* SampleCoverage)(GLfloat value, GLboolean invert);

/* gl version 1.4 */
extern void (AWGL_API* BlendColor)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void (AWGL_API* BlendEquation)(GLenum mode);
extern void (AWGL_API* BlendFuncSeparate)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
extern void (AWGL_API* MultiDrawArrays)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
extern void (AWGL_API* MultiDrawElements)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount);
extern void (AWGL_API* PointParameterf)(GLenum pname, GLfloat param);
extern void (AWGL_API* PointParameterfv)(GLenum pname, const GLfloat * params);
extern void (AWGL_API* PointParameteri)(GLenum pname, GLint param);
extern void (AWGL_API* PointParameteriv)(GLenum pname, const GLint * params);

/* gl version 1.5 */
extern void (AWGL_API* BeginQuery)(GLenum target, GLuint id);
extern void (AWGL_API* BindBuffer)(GLenum target, GLuint buffer);
extern void (AWGL_API* BufferData)(GLenum target, GLsizeiptr size, const void * data, GLenum usage);
extern void (AWGL_API* BufferSubData)(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);
extern void (AWGL_API* DeleteBuffers)(GLsizei n, const GLuint * buffers);
extern void (AWGL_API* DeleteQueries)(GLsizei n, const GLuint * ids);
extern void (AWGL_API* EndQuery)(GLenum target);
extern void (AWGL_API* GenBuffers)(GLsizei n, GLuint * buffers);
extern void (AWGL_API* GenQueries)(GLsizei n, GLuint * ids);
extern void (AWGL_API* GetBufferParameteriv)(GLenum target, GLenum pname, GLint * params);
extern void (AWGL_API* GetBufferPointerv)(GLenum target, GLenum pname, void ** params);
extern void (AWGL_API* GetBufferSubData)(GLenum target, GLintptr offset, GLsizeiptr size, void * data);
extern void (AWGL_API* GetQueryObjectiv)(GLuint id, GLenum pname, GLint * params);
extern void (AWGL_API* GetQueryObjectuiv)(GLuint id, GLenum pname, GLuint * params);
extern void (AWGL_API* GetQueryiv)(GLenum target, GLenum pname, GLint * params);
extern GLboolean (AWGL_API* IsBuffer)(GLuint buffer);
extern GLboolean (AWGL_API* IsQuery)(GLuint id);
extern void * (AWGL_API* MapBuffer)(GLenum target, GLenum access);
extern GLboolean (AWGL_API* UnmapBuffer)(GLenum target);

/* gl version 2.0 */
extern void (AWGL_API* AttachShader)(GLuint program, GLuint shader);
extern void (AWGL_API* BindAttribLocation)(GLuint program, GLuint index, const GLchar * name);
extern void (AWGL_API* BlendEquationSeparate)(GLenum modeRGB, GLenum modeAlpha);
extern void (AWGL_API* CompileShader)(GLuint shader);
extern GLuint (AWGL_API* CreateProgram)(void);
extern GLuint (AWGL_API* CreateShader)(GLenum type);
extern void (AWGL_API* DeleteProgram)(GLuint program);
extern void (AWGL_API* DeleteShader)(GLuint shader);
extern void (AWGL_API* DetachShader)(GLuint program, GLuint shader);
extern void (AWGL_API* DisableVertexAttribArray)(GLuint index);
extern void (AWGL_API* DrawBuffers)(GLsizei n, const GLenum * bufs);
extern void (AWGL_API* EnableVertexAttribArray)(GLuint index);
extern void (AWGL_API* GetActiveAttrib)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
extern void (AWGL_API* GetActiveUniform)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
extern void (AWGL_API* GetAttachedShaders)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);
extern GLint (AWGL_API* GetAttribLocation)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetProgramInfoLog)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
extern void (AWGL_API* GetProgramiv)(GLuint program, GLenum pname, GLint * params);
extern void (AWGL_API* GetShaderInfoLog)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
extern void (AWGL_API* GetShaderSource)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
extern void (AWGL_API* GetShaderiv)(GLuint shader, GLenum pname, GLint * params);
extern GLint (AWGL_API* GetUniformLocation)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetUniformfv)(GLuint program, GLint location, GLfloat * params);
extern void (AWGL_API* GetUniformiv)(GLuint program, GLint location, GLint * params);
extern void (AWGL_API* GetVertexAttribPointerv)(GLuint index, GLenum pname, void ** pointer);
extern void (AWGL_API* GetVertexAttribdv)(GLuint index, GLenum pname, GLdouble * params);
extern void (AWGL_API* GetVertexAttribfv)(GLuint index, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetVertexAttribiv)(GLuint index, GLenum pname, GLint * params);
extern GLboolean (AWGL_API* IsProgram)(GLuint program);
extern GLboolean (AWGL_API* IsShader)(GLuint shader);
extern void (AWGL_API* LinkProgram)(GLuint program);
extern void (AWGL_API* ShaderSource)(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length);
extern void (AWGL_API* StencilFuncSeparate)(GLenum face, GLenum func, GLint ref, GLuint mask);
extern void (AWGL_API* StencilMaskSeparate)(GLenum face, GLuint mask);
extern void (AWGL_API* StencilOpSeparate)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern void (AWGL_API* Uniform1f)(GLint location, GLfloat v0);
extern void (AWGL_API* Uniform1fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform1i)(GLint location, GLint v0);
extern void (AWGL_API* Uniform1iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* Uniform2f)(GLint location, GLfloat v0, GLfloat v1);
extern void (AWGL_API* Uniform2fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform2i)(GLint location, GLint v0, GLint v1);
extern void (AWGL_API* Uniform2iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* Uniform3f)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void (AWGL_API* Uniform3fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform3i)(GLint location, GLint v0, GLint v1, GLint v2);
extern void (AWGL_API* Uniform3iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* Uniform4f)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void (AWGL_API* Uniform4fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform4i)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void (AWGL_API* Uniform4iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* UniformMatrix2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UseProgram)(GLuint program);
extern void (AWGL_API* ValidateProgram)(GLuint program);
extern void (AWGL_API* VertexAttrib1d)(GLuint index, GLdouble x);
extern void (AWGL_API* VertexAttrib1dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib1f)(GLuint index, GLfloat x);
extern void (AWGL_API* VertexAttrib1fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib1s)(GLuint index, GLshort x);
extern void (AWGL_API* VertexAttrib1sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib2d)(GLuint index, GLdouble x, GLdouble y);
extern void (AWGL_API* VertexAttrib2dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib2f)(GLuint index, GLfloat x, GLfloat y);
extern void (AWGL_API* VertexAttrib2fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib2s)(GLuint index, GLshort x, GLshort y);
extern void (AWGL_API* VertexAttrib2sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib3d)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void (AWGL_API* VertexAttrib3dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib3f)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void (AWGL_API* VertexAttrib3fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib3s)(GLuint index, GLshort x, GLshort y, GLshort z);
extern void (AWGL_API* VertexAttrib3sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib4Nbv)(GLuint index, const GLbyte * v);
extern void (AWGL_API* VertexAttrib4Niv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttrib4Nsv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib4Nub)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void (AWGL_API* VertexAttrib4Nubv)(GLuint index, const GLubyte * v);
extern void (AWGL_API* VertexAttrib4Nuiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttrib4Nusv)(GLuint index, const GLushort * v);
extern void (AWGL_API* VertexAttrib4bv)(GLuint index, const GLbyte * v);
extern void (AWGL_API* VertexAttrib4d)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void (AWGL_API* VertexAttrib4dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib4f)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void (AWGL_API* VertexAttrib4fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib4iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttrib4s)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void (AWGL_API* VertexAttrib4sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib4ubv)(GLuint index, const GLubyte * v);
extern void (AWGL_API* VertexAttrib4uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttrib4usv)(GLuint index, const GLushort * v);
extern void (AWGL_API* VertexAttribPointer)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);

/* gl version 2.1 */
extern void (AWGL_API* UniformMatrix2x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix2x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix3x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix3x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix4x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix4x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);

/* gl version 3.0 */
extern void (AWGL_API* BeginConditionalRender)(GLuint id, GLenum mode);
extern void (AWGL_API* BeginTransformFeedback)(GLenum primitiveMode);
extern void (AWGL_API* BindBufferBase)(GLenum target, GLuint index, GLuint buffer);
extern void (AWGL_API* BindBufferRange)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern void (AWGL_API* BindFragDataLocation)(GLuint program, GLuint color, const GLchar * name);
extern void (AWGL_API* BindFramebuffer)(GLenum target, GLuint framebuffer);
extern void (AWGL_API* BindRenderbuffer)(GLenum target, GLuint renderbuffer);
extern void (AWGL_API* BindVertexArray)(GLuint ren_array);
extern void (AWGL_API* BlitFramebuffer)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern GLenum (AWGL_API* CheckFramebufferStatus)(GLenum target);
extern void (AWGL_API* ClampColor)(GLenum target, GLenum clamp);
extern void (AWGL_API* ClearBufferfi)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
extern void (AWGL_API* ClearBufferfv)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
extern void (AWGL_API* ClearBufferiv)(GLenum buffer, GLint drawbuffer, const GLint * value);
extern void (AWGL_API* ClearBufferuiv)(GLenum buffer, GLint drawbuffer, const GLuint * value);
extern void (AWGL_API* ColorMaski)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern void (AWGL_API* DeleteFramebuffers)(GLsizei n, const GLuint * framebuffers);
extern void (AWGL_API* DeleteRenderbuffers)(GLsizei n, const GLuint * renderbuffers);
extern void (AWGL_API* DeleteVertexArrays)(GLsizei n, const GLuint * arrays);
extern void (AWGL_API* Disablei)(GLenum target, GLuint index);
extern void (AWGL_API* Enablei)(GLenum target, GLuint index);
extern void (AWGL_API* EndConditionalRender)(void);
extern void (AWGL_API* EndTransformFeedback)(void);
extern void (AWGL_API* FlushMappedBufferRange)(GLenum target, GLintptr offset, GLsizeiptr length);
extern void (AWGL_API* FramebufferRenderbuffer)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void (AWGL_API* FramebufferTexture1D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void (AWGL_API* FramebufferTexture2D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void (AWGL_API* FramebufferTexture3D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void (AWGL_API* FramebufferTextureLayer)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern void (AWGL_API* GenFramebuffers)(GLsizei n, GLuint * framebuffers);
extern void (AWGL_API* GenRenderbuffers)(GLsizei n, GLuint * renderbuffers);
extern void (AWGL_API* GenVertexArrays)(GLsizei n, GLuint * arrays);
extern void (AWGL_API* GenerateMipmap)(GLenum target);
extern void (AWGL_API* GetBooleani_v)(GLenum target, GLuint index, GLboolean * data);
extern GLint (AWGL_API* GetFragDataLocation)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetFramebufferAttachmentParameteriv)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
extern void (AWGL_API* GetIntegeri_v)(GLenum target, GLuint index, GLint * data);
extern void (AWGL_API* GetRenderbufferParameteriv)(GLenum target, GLenum pname, GLint * params);
extern const GLubyte * (AWGL_API* GetStringi)(GLenum name, GLuint index);
extern void (AWGL_API* GetTexParameterIiv)(GLenum target, GLenum pname, GLint * params);
extern void (AWGL_API* GetTexParameterIuiv)(GLenum target, GLenum pname, GLuint * params);
extern void (AWGL_API* GetTransformFeedbackVarying)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
extern void (AWGL_API* GetUniformuiv)(GLuint program, GLint location, GLuint * params);
extern void (AWGL_API* GetVertexAttribIiv)(GLuint index, GLenum pname, GLint * params);
extern void (AWGL_API* GetVertexAttribIuiv)(GLuint index, GLenum pname, GLuint * params);
extern GLboolean (AWGL_API* IsEnabledi)(GLenum target, GLuint index);
extern GLboolean (AWGL_API* IsFramebuffer)(GLuint framebuffer);
extern GLboolean (AWGL_API* IsRenderbuffer)(GLuint renderbuffer);
extern GLboolean (AWGL_API* IsVertexArray)(GLuint ren_array);
extern void * (AWGL_API* MapBufferRange)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern void (AWGL_API* RenderbufferStorage)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void (AWGL_API* RenderbufferStorageMultisample)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern void (AWGL_API* TexParameterIiv)(GLenum target, GLenum pname, const GLint * params);
extern void (AWGL_API* TexParameterIuiv)(GLenum target, GLenum pname, const GLuint * params);
extern void (AWGL_API* TransformFeedbackVaryings)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
extern void (AWGL_API* Uniform1ui)(GLint location, GLuint v0);
extern void (AWGL_API* Uniform1uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* Uniform2ui)(GLint location, GLuint v0, GLuint v1);
extern void (AWGL_API* Uniform2uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* Uniform3ui)(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern void (AWGL_API* Uniform3uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* Uniform4ui)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern void (AWGL_API* Uniform4uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* VertexAttribI1i)(GLuint index, GLint x);
extern void (AWGL_API* VertexAttribI1iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI1ui)(GLuint index, GLuint x);
extern void (AWGL_API* VertexAttribI1uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI2i)(GLuint index, GLint x, GLint y);
extern void (AWGL_API* VertexAttribI2iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI2ui)(GLuint index, GLuint x, GLuint y);
extern void (AWGL_API* VertexAttribI2uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI3i)(GLuint index, GLint x, GLint y, GLint z);
extern void (AWGL_API* VertexAttribI3iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI3ui)(GLuint index, GLuint x, GLuint y, GLuint z);
extern void (AWGL_API* VertexAttribI3uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI4bv)(GLuint index, const GLbyte * v);
extern void (AWGL_API* VertexAttribI4i)(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern void (AWGL_API* VertexAttribI4iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI4sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttribI4ubv)(GLuint index, const GLubyte * v);
extern void (AWGL_API* VertexAttribI4ui)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern void (AWGL_API* VertexAttribI4uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI4usv)(GLuint index, const GLushort * v);
extern void (AWGL_API* VertexAttribIPointer)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);

/* gl version 3.1 */
extern void (AWGL_API* CopyBufferSubData)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern void (AWGL_API* DrawArraysInstanced)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
extern void (AWGL_API* DrawElementsInstanced)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);
extern void (AWGL_API* GetActiveUniformBlockName)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
extern void (AWGL_API* GetActiveUniformBlockiv)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
extern void (AWGL_API* GetActiveUniformName)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
extern void (AWGL_API* GetActiveUniformsiv)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
extern GLuint (AWGL_API* GetUniformBlockIndex)(GLuint program, const GLchar * uniformBlockName);
extern void (AWGL_API* GetUniformIndices)(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices);
extern void (AWGL_API* PrimitiveRestartIndex)(GLuint index);
extern void (AWGL_API* TexBuffer)(GLenum target, GLenum internalformat, GLuint buffer);
extern void (AWGL_API* UniformBlockBinding)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);

/* gl version 3.2 */
extern GLenum (AWGL_API* ClientWaitSync)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void (AWGL_API* DeleteSync)(GLsync sync);
extern void (AWGL_API* DrawElementsBaseVertex)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex);
extern void (AWGL_API* DrawElementsInstancedBaseVertex)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex);
extern void (AWGL_API* DrawRangeElementsBaseVertex)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex);
extern GLsync (AWGL_API* FenceSync)(GLenum condition, GLbitfield flags);
extern void (AWGL_API* FramebufferTexture)(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern void (AWGL_API* GetBufferParameteri64v)(GLenum target, GLenum pname, GLint64 * params);
extern void (AWGL_API* GetInteger64i_v)(GLenum target, GLuint index, GLint64 * data);
extern void (AWGL_API* GetInteger64v)(GLenum pname, GLint64 * data);
extern void (AWGL_API* GetMultisamplefv)(GLenum pname, GLuint index, GLfloat * val);
extern void (AWGL_API* GetSynciv)(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values);
extern GLboolean (AWGL_API* IsSync)(GLsync sync);
extern void (AWGL_API* MultiDrawElementsBaseVertex)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex);
extern void (AWGL_API* ProvokingVertex)(GLenum mode);
extern void (AWGL_API* SampleMaski)(GLuint maskNumber, GLbitfield mask);
extern void (AWGL_API* TexImage2DMultisample)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern void (AWGL_API* TexImage3DMultisample)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern void (AWGL_API* WaitSync)(GLsync sync, GLbitfield flags, GLuint64 timeout);

/* gl version 3.3 */
extern void (AWGL_API* BindFragDataLocationIndexed)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
extern void (AWGL_API* BindSampler)(GLuint unit, GLuint sampler);
extern void (AWGL_API* DeleteSamplers)(GLsizei count, const GLuint * samplers);
extern void (AWGL_API* GenSamplers)(GLsizei count, GLuint * samplers);
extern GLint (AWGL_API* GetFragDataIndex)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetQueryObjecti64v)(GLuint id, GLenum pname, GLint64 * params);
extern void (AWGL_API* GetQueryObjectui64v)(GLuint id, GLenum pname, GLuint64 * params);
extern void (AWGL_API* GetSamplerParameterIiv)(GLuint sampler, GLenum pname, GLint * params);
extern void (AWGL_API* GetSamplerParameterIuiv)(GLuint sampler, GLenum pname, GLuint * params);
extern void (AWGL_API* GetSamplerParameterfv)(GLuint sampler, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetSamplerParameteriv)(GLuint sampler, GLenum pname, GLint * params);
extern GLboolean (AWGL_API* IsSampler)(GLuint sampler);
extern void (AWGL_API* QueryCounter)(GLuint id, GLenum target);
extern void (AWGL_API* SamplerParameterIiv)(GLuint sampler, GLenum pname, const GLint * param);
extern void (AWGL_API* SamplerParameterIuiv)(GLuint sampler, GLenum pname, const GLuint * param);
extern void (AWGL_API* SamplerParameterf)(GLuint sampler, GLenum pname, GLfloat param);
extern void (AWGL_API* SamplerParameterfv)(GLuint sampler, GLenum pname, const GLfloat * param);
extern void (AWGL_API* SamplerParameteri)(GLuint sampler, GLenum pname, GLint param);
extern void (AWGL_API* SamplerParameteriv)(GLuint sampler, GLenum pname, const GLint * param);
extern void (AWGL_API* VertexAttribDivisor)(GLuint index, GLuint divisor);
extern void (AWGL_API* VertexAttribP1ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP1uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
extern void (AWGL_API* VertexAttribP2ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP2uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
extern void (AWGL_API* VertexAttribP3ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP3uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
extern void (AWGL_API* VertexAttribP4ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP4uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);

} //namespace _impl

/* gl version 1.0 */
inline void blend_func(GLenum sfactor, GLenum dfactor)
{
	_impl::BlendFunc(sfactor, dfactor);
}
inline void clear(GLbitfield mask)
{
	_impl::Clear(mask);
}
inline void clear_color(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	_impl::ClearColor(red, green, blue, alpha);
}
inline void clear_depth(GLdouble depth)
{
	_impl::ClearDepth(depth);
}
inline void clear_stencil(GLint s)
{
	_impl::ClearStencil(s);
}
inline void color_mask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	_impl::ColorMask(red, green, blue, alpha);
}
inline void cull_face(GLenum mode)
{
	_impl::CullFace(mode);
}
inline void depth_func(GLenum func)
{
	_impl::DepthFunc(func);
}
inline void depth_mask(GLboolean flag)
{
	_impl::DepthMask(flag);
}
inline void depth_range(GLdouble ren_near, GLdouble ren_far)
{
	_impl::DepthRange(ren_near, ren_far);
}
inline void disable(GLenum cap)
{
	_impl::Disable(cap);
}
inline void draw_buffer(GLenum buf)
{
	_impl::DrawBuffer(buf);
}
inline void enable(GLenum cap)
{
	_impl::Enable(cap);
}
inline void finish(void)
{
	_impl::Finish();
}
inline void flush(void)
{
	_impl::Flush();
}
inline void front_face(GLenum mode)
{
	_impl::FrontFace(mode);
}
inline void get_booleanv(GLenum pname, GLboolean * data)
{
	_impl::GetBooleanv(pname, data);
}
inline void get_doublev(GLenum pname, GLdouble * data)
{
	_impl::GetDoublev(pname, data);
}
inline GLenum get_error(void)
{
	return _impl::GetError();
}
inline void get_floatv(GLenum pname, GLfloat * data)
{
	_impl::GetFloatv(pname, data);
}
inline void get_integerv(GLenum pname, GLint * data)
{
	_impl::GetIntegerv(pname, data);
}
inline const GLubyte * get_string(GLenum name)
{
	return _impl::GetString(name);
}
inline void get_tex_image(GLenum target, GLint level, GLenum format, GLenum type, void * pixels)
{
	_impl::GetTexImage(target, level, format, type, pixels);
}
inline void get_tex_level_parameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)
{
	_impl::GetTexLevelParameterfv(target, level, pname, params);
}
inline void get_tex_level_parameteriv(GLenum target, GLint level, GLenum pname, GLint * params)
{
	_impl::GetTexLevelParameteriv(target, level, pname, params);
}
inline void get_tex_parameterfv(GLenum target, GLenum pname, GLfloat * params)
{
	_impl::GetTexParameterfv(target, pname, params);
}
inline void get_tex_parameteriv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetTexParameteriv(target, pname, params);
}
inline void hint(GLenum target, GLenum mode)
{
	_impl::Hint(target, mode);
}
inline GLboolean is_enabled(GLenum cap)
{
	return _impl::IsEnabled(cap);
}
inline void line_width(GLfloat width)
{
	_impl::LineWidth(width);
}
inline void logic_op(GLenum opcode)
{
	_impl::LogicOp(opcode);
}
inline void pixel_storef(GLenum pname, GLfloat param)
{
	_impl::PixelStoref(pname, param);
}
inline void pixel_storei(GLenum pname, GLint param)
{
	_impl::PixelStorei(pname, param);
}
inline void point_size(GLfloat size)
{
	_impl::PointSize(size);
}
inline void polygon_mode(GLenum face, GLenum mode)
{
	_impl::PolygonMode(face, mode);
}
inline void read_buffer(GLenum src)
{
	_impl::ReadBuffer(src);
}
inline void read_pixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)
{
	_impl::ReadPixels(x, y, width, height, format, type, pixels);
}
inline void scissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::Scissor(x, y, width, height);
}
inline void stencil_func(GLenum func, GLint ref, GLuint mask)
{
	_impl::StencilFunc(func, ref, mask);
}
inline void stencil_mask(GLuint mask)
{
	_impl::StencilMask(mask);
}
inline void stencil_op(GLenum fail, GLenum zfail, GLenum zpass)
{
	_impl::StencilOp(fail, zfail, zpass);
}
inline void tex_image1_d(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexImage1D(target, level, internalformat, width, border, format, type, pixels);
}
inline void tex_image2_d(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}
inline void tex_parameterf(GLenum target, GLenum pname, GLfloat param)
{
	_impl::TexParameterf(target, pname, param);
}
inline void tex_parameterfv(GLenum target, GLenum pname, const GLfloat * params)
{
	_impl::TexParameterfv(target, pname, params);
}
inline void tex_parameteri(GLenum target, GLenum pname, GLint param)
{
	_impl::TexParameteri(target, pname, param);
}
inline void tex_parameteriv(GLenum target, GLenum pname, const GLint * params)
{
	_impl::TexParameteriv(target, pname, params);
}
inline void viewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::Viewport(x, y, width, height);
}

/* gl version 1.1 */
inline void bind_texture(GLenum target, GLuint texture)
{
	_impl::BindTexture(target, texture);
}
inline void copy_tex_image1_d(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
	_impl::CopyTexImage1D(target, level, internalformat, x, y, width, border);
}
inline void copy_tex_image2_d(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	_impl::CopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}
inline void copy_tex_sub_image1_d(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
	_impl::CopyTexSubImage1D(target, level, xoffset, x, y, width);
}
inline void copy_tex_sub_image2_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}
inline void delete_textures(GLsizei n, const GLuint * textures)
{
	_impl::DeleteTextures(n, textures);
}
inline void draw_arrays(GLenum mode, GLint first, GLsizei count)
{
	_impl::DrawArrays(mode, first, count);
}
inline void draw_elements(GLenum mode, GLsizei count, GLenum type, const void * indices)
{
	_impl::DrawElements(mode, count, type, indices);
}
inline void gen_textures(GLsizei n, GLuint * textures)
{
	_impl::GenTextures(n, textures);
}
inline GLboolean is_texture(GLuint texture)
{
	return _impl::IsTexture(texture);
}
inline void polygon_offset(GLfloat factor, GLfloat units)
{
	_impl::PolygonOffset(factor, units);
}
inline void tex_sub_image1_d(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexSubImage1D(target, level, xoffset, width, format, type, pixels);
}
inline void tex_sub_image2_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

/* gl version 1.2 */
inline void copy_tex_sub_image3_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}
inline void draw_range_elements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)
{
	_impl::DrawRangeElements(mode, start, end, count, type, indices);
}
inline void tex_image3_d(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}
inline void tex_sub_image3_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

/* gl version 1.3 */
inline void active_texture(GLenum texture)
{
	_impl::ActiveTexture(texture);
}
inline void compressed_tex_image1_d(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
}
inline void compressed_tex_image2_d(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}
inline void compressed_tex_image3_d(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}
inline void compressed_tex_sub_image1_d(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
}
inline void compressed_tex_sub_image2_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}
inline void compressed_tex_sub_image3_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}
inline void get_compressed_tex_image(GLenum target, GLint level, void * img)
{
	_impl::GetCompressedTexImage(target, level, img);
}
inline void sample_coverage(GLfloat value, GLboolean invert)
{
	_impl::SampleCoverage(value, invert);
}

/* gl version 1.4 */
inline void blend_color(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	_impl::BlendColor(red, green, blue, alpha);
}
inline void blend_equation(GLenum mode)
{
	_impl::BlendEquation(mode);
}
inline void blend_func_separate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
	_impl::BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}
inline void multi_draw_arrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount)
{
	_impl::MultiDrawArrays(mode, first, count, drawcount);
}
inline void multi_draw_elements(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount)
{
	_impl::MultiDrawElements(mode, count, type, indices, drawcount);
}
inline void point_parameterf(GLenum pname, GLfloat param)
{
	_impl::PointParameterf(pname, param);
}
inline void point_parameterfv(GLenum pname, const GLfloat * params)
{
	_impl::PointParameterfv(pname, params);
}
inline void point_parameteri(GLenum pname, GLint param)
{
	_impl::PointParameteri(pname, param);
}
inline void point_parameteriv(GLenum pname, const GLint * params)
{
	_impl::PointParameteriv(pname, params);
}

/* gl version 1.5 */
inline void begin_query(GLenum target, GLuint id)
{
	_impl::BeginQuery(target, id);
}
inline void bind_buffer(GLenum target, GLuint buffer)
{
	_impl::BindBuffer(target, buffer);
}
inline void buffer_data(GLenum target, GLsizeiptr size, const void * data, GLenum usage)
{
	_impl::BufferData(target, size, data, usage);
}
inline void buffer_sub_data(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)
{
	_impl::BufferSubData(target, offset, size, data);
}
inline void delete_buffers(GLsizei n, const GLuint * buffers)
{
	_impl::DeleteBuffers(n, buffers);
}
inline void delete_queries(GLsizei n, const GLuint * ids)
{
	_impl::DeleteQueries(n, ids);
}
inline void end_query(GLenum target)
{
	_impl::EndQuery(target);
}
inline void gen_buffers(GLsizei n, GLuint * buffers)
{
	_impl::GenBuffers(n, buffers);
}
inline void gen_queries(GLsizei n, GLuint * ids)
{
	_impl::GenQueries(n, ids);
}
inline void get_buffer_parameteriv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetBufferParameteriv(target, pname, params);
}
inline void get_buffer_pointerv(GLenum target, GLenum pname, void ** params)
{
	_impl::GetBufferPointerv(target, pname, params);
}
inline void get_buffer_sub_data(GLenum target, GLintptr offset, GLsizeiptr size, void * data)
{
	_impl::GetBufferSubData(target, offset, size, data);
}
inline void get_query_objectiv(GLuint id, GLenum pname, GLint * params)
{
	_impl::GetQueryObjectiv(id, pname, params);
}
inline void get_query_objectuiv(GLuint id, GLenum pname, GLuint * params)
{
	_impl::GetQueryObjectuiv(id, pname, params);
}
inline void get_queryiv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetQueryiv(target, pname, params);
}
inline GLboolean is_buffer(GLuint buffer)
{
	return _impl::IsBuffer(buffer);
}
inline GLboolean is_query(GLuint id)
{
	return _impl::IsQuery(id);
}
inline void * map_buffer(GLenum target, GLenum access)
{
	return _impl::MapBuffer(target, access);
}
inline GLboolean unmap_buffer(GLenum target)
{
	return _impl::UnmapBuffer(target);
}

/* gl version 2.0 */
inline void attach_shader(GLuint program, GLuint shader)
{
	_impl::AttachShader(program, shader);
}
inline void bind_attrib_location(GLuint program, GLuint index, const GLchar * name)
{
	_impl::BindAttribLocation(program, index, name);
}
inline void blend_equation_separate(GLenum modeRGB, GLenum modeAlpha)
{
	_impl::BlendEquationSeparate(modeRGB, modeAlpha);
}
inline void compile_shader(GLuint shader)
{
	_impl::CompileShader(shader);
}
inline GLuint create_program(void)
{
	return _impl::CreateProgram();
}
inline GLuint create_shader(GLenum type)
{
	return _impl::CreateShader(type);
}
inline void delete_program(GLuint program)
{
	_impl::DeleteProgram(program);
}
inline void delete_shader(GLuint shader)
{
	_impl::DeleteShader(shader);
}
inline void detach_shader(GLuint program, GLuint shader)
{
	_impl::DetachShader(program, shader);
}
inline void disable_vertex_attrib_array(GLuint index)
{
	_impl::DisableVertexAttribArray(index);
}
inline void draw_buffers(GLsizei n, const GLenum * bufs)
{
	_impl::DrawBuffers(n, bufs);
}
inline void enable_vertex_attrib_array(GLuint index)
{
	_impl::EnableVertexAttribArray(index);
}
inline void get_active_attrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	_impl::GetActiveAttrib(program, index, bufSize, length, size, type, name);
}
inline void get_active_uniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	_impl::GetActiveUniform(program, index, bufSize, length, size, type, name);
}
inline void get_attached_shaders(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders)
{
	_impl::GetAttachedShaders(program, maxCount, count, shaders);
}
inline GLint get_attrib_location(GLuint program, const GLchar * name)
{
	return _impl::GetAttribLocation(program, name);
}
inline void get_program_info_log(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	_impl::GetProgramInfoLog(program, bufSize, length, infoLog);
}
inline void get_programiv(GLuint program, GLenum pname, GLint * params)
{
	_impl::GetProgramiv(program, pname, params);
}
inline void get_shader_info_log(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	_impl::GetShaderInfoLog(shader, bufSize, length, infoLog);
}
inline void get_shader_source(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source)
{
	_impl::GetShaderSource(shader, bufSize, length, source);
}
inline void get_shaderiv(GLuint shader, GLenum pname, GLint * params)
{
	_impl::GetShaderiv(shader, pname, params);
}
inline GLint get_uniform_location(GLuint program, const GLchar * name)
{
	return _impl::GetUniformLocation(program, name);
}
inline void get_uniformfv(GLuint program, GLint location, GLfloat * params)
{
	_impl::GetUniformfv(program, location, params);
}
inline void get_uniformiv(GLuint program, GLint location, GLint * params)
{
	_impl::GetUniformiv(program, location, params);
}
inline void get_vertex_attrib_pointerv(GLuint index, GLenum pname, void ** pointer)
{
	_impl::GetVertexAttribPointerv(index, pname, pointer);
}
inline void get_vertex_attribdv(GLuint index, GLenum pname, GLdouble * params)
{
	_impl::GetVertexAttribdv(index, pname, params);
}
inline void get_vertex_attribfv(GLuint index, GLenum pname, GLfloat * params)
{
	_impl::GetVertexAttribfv(index, pname, params);
}
inline void get_vertex_attribiv(GLuint index, GLenum pname, GLint * params)
{
	_impl::GetVertexAttribiv(index, pname, params);
}
inline GLboolean is_program(GLuint program)
{
	return _impl::IsProgram(program);
}
inline GLboolean is_shader(GLuint shader)
{
	return _impl::IsShader(shader);
}
inline void link_program(GLuint program)
{
	_impl::LinkProgram(program);
}
inline void shader_source(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length)
{
	_impl::ShaderSource(shader, count, string, length);
}
inline void stencil_func_separate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
	_impl::StencilFuncSeparate(face, func, ref, mask);
}
inline void stencil_mask_separate(GLenum face, GLuint mask)
{
	_impl::StencilMaskSeparate(face, mask);
}
inline void stencil_op_separate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
	_impl::StencilOpSeparate(face, sfail, dpfail, dppass);
}
inline void uniform1f(GLint location, GLfloat v0)
{
	_impl::Uniform1f(location, v0);
}
inline void uniform1fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform1fv(location, count, value);
}
inline void uniform1i(GLint location, GLint v0)
{
	_impl::Uniform1i(location, v0);
}
inline void uniform1iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform1iv(location, count, value);
}
inline void uniform2f(GLint location, GLfloat v0, GLfloat v1)
{
	_impl::Uniform2f(location, v0, v1);
}
inline void uniform2fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform2fv(location, count, value);
}
inline void uniform2i(GLint location, GLint v0, GLint v1)
{
	_impl::Uniform2i(location, v0, v1);
}
inline void uniform2iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform2iv(location, count, value);
}
inline void uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
	_impl::Uniform3f(location, v0, v1, v2);
}
inline void uniform3fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform3fv(location, count, value);
}
inline void uniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
	_impl::Uniform3i(location, v0, v1, v2);
}
inline void uniform3iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform3iv(location, count, value);
}
inline void uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
	_impl::Uniform4f(location, v0, v1, v2, v3);
}
inline void uniform4fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform4fv(location, count, value);
}
inline void uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
	_impl::Uniform4i(location, v0, v1, v2, v3);
}
inline void uniform4iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform4iv(location, count, value);
}
inline void uniform_matrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix2fv(location, count, transpose, value);
}
inline void uniform_matrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix3fv(location, count, transpose, value);
}
inline void uniform_matrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix4fv(location, count, transpose, value);
}
inline void use_program(GLuint program)
{
	_impl::UseProgram(program);
}
inline void validate_program(GLuint program)
{
	_impl::ValidateProgram(program);
}
inline void vertex_attrib1d(GLuint index, GLdouble x)
{
	_impl::VertexAttrib1d(index, x);
}
inline void vertex_attrib1dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib1dv(index, v);
}
inline void vertex_attrib1f(GLuint index, GLfloat x)
{
	_impl::VertexAttrib1f(index, x);
}
inline void vertex_attrib1fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib1fv(index, v);
}
inline void vertex_attrib1s(GLuint index, GLshort x)
{
	_impl::VertexAttrib1s(index, x);
}
inline void vertex_attrib1sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib1sv(index, v);
}
inline void vertex_attrib2d(GLuint index, GLdouble x, GLdouble y)
{
	_impl::VertexAttrib2d(index, x, y);
}
inline void vertex_attrib2dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib2dv(index, v);
}
inline void vertex_attrib2f(GLuint index, GLfloat x, GLfloat y)
{
	_impl::VertexAttrib2f(index, x, y);
}
inline void vertex_attrib2fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib2fv(index, v);
}
inline void vertex_attrib2s(GLuint index, GLshort x, GLshort y)
{
	_impl::VertexAttrib2s(index, x, y);
}
inline void vertex_attrib2sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib2sv(index, v);
}
inline void vertex_attrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
	_impl::VertexAttrib3d(index, x, y, z);
}
inline void vertex_attrib3dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib3dv(index, v);
}
inline void vertex_attrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
	_impl::VertexAttrib3f(index, x, y, z);
}
inline void vertex_attrib3fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib3fv(index, v);
}
inline void vertex_attrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
	_impl::VertexAttrib3s(index, x, y, z);
}
inline void vertex_attrib3sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib3sv(index, v);
}
inline void vertex_attrib4_nbv(GLuint index, const GLbyte * v)
{
	_impl::VertexAttrib4Nbv(index, v);
}
inline void vertex_attrib4_niv(GLuint index, const GLint * v)
{
	_impl::VertexAttrib4Niv(index, v);
}
inline void vertex_attrib4_nsv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib4Nsv(index, v);
}
inline void vertex_attrib4_nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
	_impl::VertexAttrib4Nub(index, x, y, z, w);
}
inline void vertex_attrib4_nubv(GLuint index, const GLubyte * v)
{
	_impl::VertexAttrib4Nubv(index, v);
}
inline void vertex_attrib4_nuiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttrib4Nuiv(index, v);
}
inline void vertex_attrib4_nusv(GLuint index, const GLushort * v)
{
	_impl::VertexAttrib4Nusv(index, v);
}
inline void vertex_attrib4bv(GLuint index, const GLbyte * v)
{
	_impl::VertexAttrib4bv(index, v);
}
inline void vertex_attrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	_impl::VertexAttrib4d(index, x, y, z, w);
}
inline void vertex_attrib4dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib4dv(index, v);
}
inline void vertex_attrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	_impl::VertexAttrib4f(index, x, y, z, w);
}
inline void vertex_attrib4fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib4fv(index, v);
}
inline void vertex_attrib4iv(GLuint index, const GLint * v)
{
	_impl::VertexAttrib4iv(index, v);
}
inline void vertex_attrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
	_impl::VertexAttrib4s(index, x, y, z, w);
}
inline void vertex_attrib4sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib4sv(index, v);
}
inline void vertex_attrib4ubv(GLuint index, const GLubyte * v)
{
	_impl::VertexAttrib4ubv(index, v);
}
inline void vertex_attrib4uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttrib4uiv(index, v);
}
inline void vertex_attrib4usv(GLuint index, const GLushort * v)
{
	_impl::VertexAttrib4usv(index, v);
}
inline void vertex_attrib_pointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)
{
	_impl::VertexAttribPointer(index, size, type, normalized, stride, pointer);
}

/* gl version 2.1 */
inline void uniform_matrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix2x3fv(location, count, transpose, value);
}
inline void uniform_matrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix2x4fv(location, count, transpose, value);
}
inline void uniform_matrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix3x2fv(location, count, transpose, value);
}
inline void uniform_matrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix3x4fv(location, count, transpose, value);
}
inline void uniform_matrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix4x2fv(location, count, transpose, value);
}
inline void uniform_matrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix4x3fv(location, count, transpose, value);
}

/* gl version 3.0 */
inline void begin_conditional_render(GLuint id, GLenum mode)
{
	_impl::BeginConditionalRender(id, mode);
}
inline void begin_transform_feedback(GLenum primitiveMode)
{
	_impl::BeginTransformFeedback(primitiveMode);
}
inline void bind_buffer_base(GLenum target, GLuint index, GLuint buffer)
{
	_impl::BindBufferBase(target, index, buffer);
}
inline void bind_buffer_range(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	_impl::BindBufferRange(target, index, buffer, offset, size);
}
inline void bind_frag_data_location(GLuint program, GLuint color, const GLchar * name)
{
	_impl::BindFragDataLocation(program, color, name);
}
inline void bind_framebuffer(GLenum target, GLuint framebuffer)
{
	_impl::BindFramebuffer(target, framebuffer);
}
inline void bind_renderbuffer(GLenum target, GLuint renderbuffer)
{
	_impl::BindRenderbuffer(target, renderbuffer);
}
inline void bind_vertex_array(GLuint ren_array)
{
	_impl::BindVertexArray(ren_array);
}
inline void blit_framebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
	_impl::BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}
inline GLenum check_framebuffer_status(GLenum target)
{
	return _impl::CheckFramebufferStatus(target);
}
inline void clamp_color(GLenum target, GLenum clamp)
{
	_impl::ClampColor(target, clamp);
}
inline void clear_bufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
	_impl::ClearBufferfi(buffer, drawbuffer, depth, stencil);
}
inline void clear_bufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value)
{
	_impl::ClearBufferfv(buffer, drawbuffer, value);
}
inline void clear_bufferiv(GLenum buffer, GLint drawbuffer, const GLint * value)
{
	_impl::ClearBufferiv(buffer, drawbuffer, value);
}
inline void clear_bufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value)
{
	_impl::ClearBufferuiv(buffer, drawbuffer, value);
}
inline void color_maski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
	_impl::ColorMaski(index, r, g, b, a);
}
inline void delete_framebuffers(GLsizei n, const GLuint * framebuffers)
{
	_impl::DeleteFramebuffers(n, framebuffers);
}
inline void delete_renderbuffers(GLsizei n, const GLuint * renderbuffers)
{
	_impl::DeleteRenderbuffers(n, renderbuffers);
}
inline void delete_vertex_arrays(GLsizei n, const GLuint * arrays)
{
	_impl::DeleteVertexArrays(n, arrays);
}
inline void disablei(GLenum target, GLuint index)
{
	_impl::Disablei(target, index);
}
inline void enablei(GLenum target, GLuint index)
{
	_impl::Enablei(target, index);
}
inline void end_conditional_render(void)
{
	_impl::EndConditionalRender();
}
inline void end_transform_feedback(void)
{
	_impl::EndTransformFeedback();
}
inline void flush_mapped_buffer_range(GLenum target, GLintptr offset, GLsizeiptr length)
{
	_impl::FlushMappedBufferRange(target, offset, length);
}
inline void framebuffer_renderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	_impl::FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}
inline void framebuffer_texture1_d(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	_impl::FramebufferTexture1D(target, attachment, textarget, texture, level);
}
inline void framebuffer_texture2_d(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	_impl::FramebufferTexture2D(target, attachment, textarget, texture, level);
}
inline void framebuffer_texture3_d(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
	_impl::FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
}
inline void framebuffer_texture_layer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
	_impl::FramebufferTextureLayer(target, attachment, texture, level, layer);
}
inline void gen_framebuffers(GLsizei n, GLuint * framebuffers)
{
	_impl::GenFramebuffers(n, framebuffers);
}
inline void gen_renderbuffers(GLsizei n, GLuint * renderbuffers)
{
	_impl::GenRenderbuffers(n, renderbuffers);
}
inline void gen_vertex_arrays(GLsizei n, GLuint * arrays)
{
	_impl::GenVertexArrays(n, arrays);
}
inline void generate_mipmap(GLenum target)
{
	_impl::GenerateMipmap(target);
}
inline void get_booleani_v(GLenum target, GLuint index, GLboolean * data)
{
	_impl::GetBooleani_v(target, index, data);
}
inline GLint get_frag_data_location(GLuint program, const GLchar * name)
{
	return _impl::GetFragDataLocation(program, name);
}
inline void get_framebuffer_attachment_parameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params)
{
	_impl::GetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}
inline void get_integeri_v(GLenum target, GLuint index, GLint * data)
{
	_impl::GetIntegeri_v(target, index, data);
}
inline void get_renderbuffer_parameteriv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetRenderbufferParameteriv(target, pname, params);
}
inline const GLubyte * get_stringi(GLenum name, GLuint index)
{
	return _impl::GetStringi(name, index);
}
inline void get_tex_parameter_iiv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetTexParameterIiv(target, pname, params);
}
inline void get_tex_parameter_iuiv(GLenum target, GLenum pname, GLuint * params)
{
	_impl::GetTexParameterIuiv(target, pname, params);
}
inline void get_transform_feedback_varying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name)
{
	_impl::GetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
}
inline void get_uniformuiv(GLuint program, GLint location, GLuint * params)
{
	_impl::GetUniformuiv(program, location, params);
}
inline void get_vertex_attrib_iiv(GLuint index, GLenum pname, GLint * params)
{
	_impl::GetVertexAttribIiv(index, pname, params);
}
inline void get_vertex_attrib_iuiv(GLuint index, GLenum pname, GLuint * params)
{
	_impl::GetVertexAttribIuiv(index, pname, params);
}
inline GLboolean is_enabledi(GLenum target, GLuint index)
{
	return _impl::IsEnabledi(target, index);
}
inline GLboolean is_framebuffer(GLuint framebuffer)
{
	return _impl::IsFramebuffer(framebuffer);
}
inline GLboolean is_renderbuffer(GLuint renderbuffer)
{
	return _impl::IsRenderbuffer(renderbuffer);
}
inline GLboolean is_vertex_array(GLuint ren_array)
{
	return _impl::IsVertexArray(ren_array);
}
inline void * map_buffer_range(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
	return _impl::MapBufferRange(target, offset, length, access);
}
inline void renderbuffer_storage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	_impl::RenderbufferStorage(target, internalformat, width, height);
}
inline void renderbuffer_storage_multisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	_impl::RenderbufferStorageMultisample(target, samples, internalformat, width, height);
}
inline void tex_parameter_iiv(GLenum target, GLenum pname, const GLint * params)
{
	_impl::TexParameterIiv(target, pname, params);
}
inline void tex_parameter_iuiv(GLenum target, GLenum pname, const GLuint * params)
{
	_impl::TexParameterIuiv(target, pname, params);
}
inline void transform_feedback_varyings(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode)
{
	_impl::TransformFeedbackVaryings(program, count, varyings, bufferMode);
}
inline void uniform1ui(GLint location, GLuint v0)
{
	_impl::Uniform1ui(location, v0);
}
inline void uniform1uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform1uiv(location, count, value);
}
inline void uniform2ui(GLint location, GLuint v0, GLuint v1)
{
	_impl::Uniform2ui(location, v0, v1);
}
inline void uniform2uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform2uiv(location, count, value);
}
inline void uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
	_impl::Uniform3ui(location, v0, v1, v2);
}
inline void uniform3uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform3uiv(location, count, value);
}
inline void uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
	_impl::Uniform4ui(location, v0, v1, v2, v3);
}
inline void uniform4uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform4uiv(location, count, value);
}
inline void vertex_attrib_i1i(GLuint index, GLint x)
{
	_impl::VertexAttribI1i(index, x);
}
inline void vertex_attrib_i1iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI1iv(index, v);
}
inline void vertex_attrib_i1ui(GLuint index, GLuint x)
{
	_impl::VertexAttribI1ui(index, x);
}
inline void vertex_attrib_i1uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI1uiv(index, v);
}
inline void vertex_attrib_i2i(GLuint index, GLint x, GLint y)
{
	_impl::VertexAttribI2i(index, x, y);
}
inline void vertex_attrib_i2iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI2iv(index, v);
}
inline void vertex_attrib_i2ui(GLuint index, GLuint x, GLuint y)
{
	_impl::VertexAttribI2ui(index, x, y);
}
inline void vertex_attrib_i2uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI2uiv(index, v);
}
inline void vertex_attrib_i3i(GLuint index, GLint x, GLint y, GLint z)
{
	_impl::VertexAttribI3i(index, x, y, z);
}
inline void vertex_attrib_i3iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI3iv(index, v);
}
inline void vertex_attrib_i3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
	_impl::VertexAttribI3ui(index, x, y, z);
}
inline void vertex_attrib_i3uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI3uiv(index, v);
}
inline void vertex_attrib_i4bv(GLuint index, const GLbyte * v)
{
	_impl::VertexAttribI4bv(index, v);
}
inline void vertex_attrib_i4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
	_impl::VertexAttribI4i(index, x, y, z, w);
}
inline void vertex_attrib_i4iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI4iv(index, v);
}
inline void vertex_attrib_i4sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttribI4sv(index, v);
}
inline void vertex_attrib_i4ubv(GLuint index, const GLubyte * v)
{
	_impl::VertexAttribI4ubv(index, v);
}
inline void vertex_attrib_i4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
	_impl::VertexAttribI4ui(index, x, y, z, w);
}
inline void vertex_attrib_i4uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI4uiv(index, v);
}
inline void vertex_attrib_i4usv(GLuint index, const GLushort * v)
{
	_impl::VertexAttribI4usv(index, v);
}
inline void vertex_attrib_i_pointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
	_impl::VertexAttribIPointer(index, size, type, stride, pointer);
}

/* gl version 3.1 */
inline void copy_buffer_sub_data(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
	_impl::CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
}
inline void draw_arrays_instanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)
{
	_impl::DrawArraysInstanced(mode, first, count, instancecount);
}
inline void draw_elements_instanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount)
{
	_impl::DrawElementsInstanced(mode, count, type, indices, instancecount);
}
inline void get_active_uniform_block_name(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName)
{
	_impl::GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}
inline void get_active_uniform_blockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params)
{
	_impl::GetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}
inline void get_active_uniform_name(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName)
{
	_impl::GetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
}
inline void get_active_uniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params)
{
	_impl::GetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
}
inline GLuint get_uniform_block_index(GLuint program, const GLchar * uniformBlockName)
{
	return _impl::GetUniformBlockIndex(program, uniformBlockName);
}
inline void get_uniform_indices(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices)
{
	_impl::GetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}
inline void primitive_restart_index(GLuint index)
{
	_impl::PrimitiveRestartIndex(index);
}
inline void tex_buffer(GLenum target, GLenum internalformat, GLuint buffer)
{
	_impl::TexBuffer(target, internalformat, buffer);
}
inline void uniform_block_binding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
	_impl::UniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}

/* gl version 3.2 */
inline GLenum client_wait_sync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
	return _impl::ClientWaitSync(sync, flags, timeout);
}
inline void delete_sync(GLsync sync)
{
	_impl::DeleteSync(sync);
}
inline void draw_elements_base_vertex(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
	_impl::DrawElementsBaseVertex(mode, count, type, indices, basevertex);
}
inline void draw_elements_instanced_base_vertex(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex)
{
	_impl::DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
}
inline void draw_range_elements_base_vertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
	_impl::DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
}
inline GLsync fence_sync(GLenum condition, GLbitfield flags)
{
	return _impl::FenceSync(condition, flags);
}
inline void framebuffer_texture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
	_impl::FramebufferTexture(target, attachment, texture, level);
}
inline void get_buffer_parameteri64v(GLenum target, GLenum pname, GLint64 * params)
{
	_impl::GetBufferParameteri64v(target, pname, params);
}
inline void get_integer64i_v(GLenum target, GLuint index, GLint64 * data)
{
	_impl::GetInteger64i_v(target, index, data);
}
inline void get_integer64v(GLenum pname, GLint64 * data)
{
	_impl::GetInteger64v(pname, data);
}
inline void get_multisamplefv(GLenum pname, GLuint index, GLfloat * val)
{
	_impl::GetMultisamplefv(pname, index, val);
}
inline void get_synciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values)
{
	_impl::GetSynciv(sync, pname, bufSize, length, values);
}
inline GLboolean is_sync(GLsync sync)
{
	return _impl::IsSync(sync);
}
inline void multi_draw_elements_base_vertex(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex)
{
	_impl::MultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);
}
inline void provoking_vertex(GLenum mode)
{
	_impl::ProvokingVertex(mode);
}
inline void sample_maski(GLuint maskNumber, GLbitfield mask)
{
	_impl::SampleMaski(maskNumber, mask);
}
inline void tex_image2_d_multisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
	_impl::TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}
inline void tex_image3_d_multisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
	_impl::TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}
inline void wait_sync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
	_impl::WaitSync(sync, flags, timeout);
}

/* gl version 3.3 */
inline void bind_frag_data_location_indexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name)
{
	_impl::BindFragDataLocationIndexed(program, colorNumber, index, name);
}
inline void bind_sampler(GLuint unit, GLuint sampler)
{
	_impl::BindSampler(unit, sampler);
}
inline void delete_samplers(GLsizei count, const GLuint * samplers)
{
	_impl::DeleteSamplers(count, samplers);
}
inline void gen_samplers(GLsizei count, GLuint * samplers)
{
	_impl::GenSamplers(count, samplers);
}
inline GLint get_frag_data_index(GLuint program, const GLchar * name)
{
	return _impl::GetFragDataIndex(program, name);
}
inline void get_query_objecti64v(GLuint id, GLenum pname, GLint64 * params)
{
	_impl::GetQueryObjecti64v(id, pname, params);
}
inline void get_query_objectui64v(GLuint id, GLenum pname, GLuint64 * params)
{
	_impl::GetQueryObjectui64v(id, pname, params);
}
inline void get_sampler_parameter_iiv(GLuint sampler, GLenum pname, GLint * params)
{
	_impl::GetSamplerParameterIiv(sampler, pname, params);
}
inline void get_sampler_parameter_iuiv(GLuint sampler, GLenum pname, GLuint * params)
{
	_impl::GetSamplerParameterIuiv(sampler, pname, params);
}
inline void get_sampler_parameterfv(GLuint sampler, GLenum pname, GLfloat * params)
{
	_impl::GetSamplerParameterfv(sampler, pname, params);
}
inline void get_sampler_parameteriv(GLuint sampler, GLenum pname, GLint * params)
{
	_impl::GetSamplerParameteriv(sampler, pname, params);
}
inline GLboolean is_sampler(GLuint sampler)
{
	return _impl::IsSampler(sampler);
}
inline void query_counter(GLuint id, GLenum target)
{
	_impl::QueryCounter(id, target);
}
inline void sampler_parameter_iiv(GLuint sampler, GLenum pname, const GLint * param)
{
	_impl::SamplerParameterIiv(sampler, pname, param);
}
inline void sampler_parameter_iuiv(GLuint sampler, GLenum pname, const GLuint * param)
{
	_impl::SamplerParameterIuiv(sampler, pname, param);
}
inline void sampler_parameterf(GLuint sampler, GLenum pname, GLfloat param)
{
	_impl::SamplerParameterf(sampler, pname, param);
}
inline void sampler_parameterfv(GLuint sampler, GLenum pname, const GLfloat * param)
{
	_impl::SamplerParameterfv(sampler, pname, param);
}
inline void sampler_parameteri(GLuint sampler, GLenum pname, GLint param)
{
	_impl::SamplerParameteri(sampler, pname, param);
}
inline void sampler_parameteriv(GLuint sampler, GLenum pname, const GLint * param)
{
	_impl::SamplerParameteriv(sampler, pname, param);
}
inline void vertex_attrib_divisor(GLuint index, GLuint divisor)
{
	_impl::VertexAttribDivisor(index, divisor);
}
inline void vertex_attrib_p1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP1ui(index, type, normalized, value);
}
inline void vertex_attrib_p1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP1uiv(index, type, normalized, value);
}
inline void vertex_attrib_p2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP2ui(index, type, normalized, value);
}
inline void vertex_attrib_p2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP2uiv(index, type, normalized, value);
}
inline void vertex_attrib_p3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP3ui(index, type, normalized, value);
}
inline void vertex_attrib_p3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP3uiv(index, type, normalized, value);
}
inline void vertex_attrib_p4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP4ui(index, type, normalized, value);
}
inline void vertex_attrib_p4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP4uiv(index, type, normalized, value);
}

} //namespace gl
} //namespace aw
#endif//aw_gl_ext_opengl_h
