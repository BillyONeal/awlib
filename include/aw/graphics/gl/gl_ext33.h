/*
 * This file is automatically generated.
 */
#ifndef aw_gl_ext_opengl_h
#define aw_gl_ext_opengl_h
#include "types.h"
#include "gl_ext_enum33.h"

namespace aw {
namespace gl {
namespace ext {
struct load_result {
	explicit operator bool() const
	{
		return is_loaded;
	}
	
	int num_missing() const { return missing; }
	
	load_result() = default;
	load_result(bool is_loaded, int num_missing)
		: is_loaded{is_loaded}, missing{num_missing}
	{}

private:
	bool is_loaded   = false;
	int  missing = 0;
};

} //namespace ext

namespace sys {
ext::load_result load_functions_3_3();

int get_minor_version();
int get_major_version();
bool is_version_geq(int major, int minor);
} //namespace sys

namespace _impl {
/* gl version 1.0 */
extern void (AWGL_API* BlendFunc)(GLenum sfactor, GLenum dfactor);
extern void (AWGL_API* Clear)(GLbitfield mask);
extern void (AWGL_API* ClearColor)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void (AWGL_API* ClearDepth)(GLdouble depth);
extern void (AWGL_API* ClearStencil)(GLint s);
extern void (AWGL_API* ColorMask)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void (AWGL_API* CullFace)(GLenum mode);
extern void (AWGL_API* DepthFunc)(GLenum func);
extern void (AWGL_API* DepthMask)(GLboolean flag);
extern void (AWGL_API* DepthRange)(GLdouble ren_near, GLdouble ren_far);
extern void (AWGL_API* Disable)(GLenum cap);
extern void (AWGL_API* DrawBuffer)(GLenum buf);
extern void (AWGL_API* Enable)(GLenum cap);
extern void (AWGL_API* Finish)(void);
extern void (AWGL_API* Flush)(void);
extern void (AWGL_API* FrontFace)(GLenum mode);
extern void (AWGL_API* GetBooleanv)(GLenum pname, GLboolean * data);
extern void (AWGL_API* GetDoublev)(GLenum pname, GLdouble * data);
extern GLenum (AWGL_API* GetError)(void);
extern void (AWGL_API* GetFloatv)(GLenum pname, GLfloat * data);
extern void (AWGL_API* GetIntegerv)(GLenum pname, GLint * data);
extern const GLubyte * (AWGL_API* GetString)(GLenum name);
extern void (AWGL_API* GetTexImage)(GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
extern void (AWGL_API* GetTexLevelParameterfv)(GLenum target, GLint level, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetTexLevelParameteriv)(GLenum target, GLint level, GLenum pname, GLint * params);
extern void (AWGL_API* GetTexParameterfv)(GLenum target, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetTexParameteriv)(GLenum target, GLenum pname, GLint * params);
extern void (AWGL_API* Hint)(GLenum target, GLenum mode);
extern GLboolean (AWGL_API* IsEnabled)(GLenum cap);
extern void (AWGL_API* LineWidth)(GLfloat width);
extern void (AWGL_API* LogicOp)(GLenum opcode);
extern void (AWGL_API* PixelStoref)(GLenum pname, GLfloat param);
extern void (AWGL_API* PixelStorei)(GLenum pname, GLint param);
extern void (AWGL_API* PointSize)(GLfloat size);
extern void (AWGL_API* PolygonMode)(GLenum face, GLenum mode);
extern void (AWGL_API* ReadBuffer)(GLenum src);
extern void (AWGL_API* ReadPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels);
extern void (AWGL_API* Scissor)(GLint x, GLint y, GLsizei width, GLsizei height);
extern void (AWGL_API* StencilFunc)(GLenum func, GLint ref, GLuint mask);
extern void (AWGL_API* StencilMask)(GLuint mask);
extern void (AWGL_API* StencilOp)(GLenum fail, GLenum zfail, GLenum zpass);
extern void (AWGL_API* TexImage1D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexImage2D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexParameterf)(GLenum target, GLenum pname, GLfloat param);
extern void (AWGL_API* TexParameterfv)(GLenum target, GLenum pname, const GLfloat * params);
extern void (AWGL_API* TexParameteri)(GLenum target, GLenum pname, GLint param);
extern void (AWGL_API* TexParameteriv)(GLenum target, GLenum pname, const GLint * params);
extern void (AWGL_API* Viewport)(GLint x, GLint y, GLsizei width, GLsizei height);

/* gl version 1.1 */
extern void (AWGL_API* BindTexture)(GLenum target, GLuint texture);
extern void (AWGL_API* CopyTexImage1D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void (AWGL_API* CopyTexImage2D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void (AWGL_API* CopyTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void (AWGL_API* CopyTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void (AWGL_API* DeleteTextures)(GLsizei n, const GLuint * textures);
extern void (AWGL_API* DrawArrays)(GLenum mode, GLint first, GLsizei count);
extern void (AWGL_API* DrawElements)(GLenum mode, GLsizei count, GLenum type, const void * indices);
extern void (AWGL_API* GenTextures)(GLsizei n, GLuint * textures);
extern GLboolean (AWGL_API* IsTexture)(GLuint texture);
extern void (AWGL_API* PolygonOffset)(GLfloat factor, GLfloat units);
extern void (AWGL_API* TexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);

/* gl version 1.2 */
extern void (AWGL_API* CopyTexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void (AWGL_API* DrawRangeElements)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
extern void (AWGL_API* TexImage3D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
extern void (AWGL_API* TexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);

/* gl version 1.3 */
extern void (AWGL_API* ActiveTexture)(GLenum texture);
extern void (AWGL_API* CompressedTexImage1D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexImage2D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexImage3D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
extern void (AWGL_API* CompressedTexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
extern void (AWGL_API* GetCompressedTexImage)(GLenum target, GLint level, void * img);
extern void (AWGL_API* SampleCoverage)(GLfloat value, GLboolean invert);

/* gl version 1.4 */
extern void (AWGL_API* BlendColor)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void (AWGL_API* BlendEquation)(GLenum mode);
extern void (AWGL_API* BlendFuncSeparate)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
extern void (AWGL_API* MultiDrawArrays)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
extern void (AWGL_API* MultiDrawElements)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount);
extern void (AWGL_API* PointParameterf)(GLenum pname, GLfloat param);
extern void (AWGL_API* PointParameterfv)(GLenum pname, const GLfloat * params);
extern void (AWGL_API* PointParameteri)(GLenum pname, GLint param);
extern void (AWGL_API* PointParameteriv)(GLenum pname, const GLint * params);

/* gl version 1.5 */
extern void (AWGL_API* BeginQuery)(GLenum target, GLuint id);
extern void (AWGL_API* BindBuffer)(GLenum target, GLuint buffer);
extern void (AWGL_API* BufferData)(GLenum target, GLsizeiptr size, const void * data, GLenum usage);
extern void (AWGL_API* BufferSubData)(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);
extern void (AWGL_API* DeleteBuffers)(GLsizei n, const GLuint * buffers);
extern void (AWGL_API* DeleteQueries)(GLsizei n, const GLuint * ids);
extern void (AWGL_API* EndQuery)(GLenum target);
extern void (AWGL_API* GenBuffers)(GLsizei n, GLuint * buffers);
extern void (AWGL_API* GenQueries)(GLsizei n, GLuint * ids);
extern void (AWGL_API* GetBufferParameteriv)(GLenum target, GLenum pname, GLint * params);
extern void (AWGL_API* GetBufferPointerv)(GLenum target, GLenum pname, void ** params);
extern void (AWGL_API* GetBufferSubData)(GLenum target, GLintptr offset, GLsizeiptr size, void * data);
extern void (AWGL_API* GetQueryObjectiv)(GLuint id, GLenum pname, GLint * params);
extern void (AWGL_API* GetQueryObjectuiv)(GLuint id, GLenum pname, GLuint * params);
extern void (AWGL_API* GetQueryiv)(GLenum target, GLenum pname, GLint * params);
extern GLboolean (AWGL_API* IsBuffer)(GLuint buffer);
extern GLboolean (AWGL_API* IsQuery)(GLuint id);
extern void * (AWGL_API* MapBuffer)(GLenum target, GLenum access);
extern GLboolean (AWGL_API* UnmapBuffer)(GLenum target);

/* gl version 2.0 */
extern void (AWGL_API* AttachShader)(GLuint program, GLuint shader);
extern void (AWGL_API* BindAttribLocation)(GLuint program, GLuint index, const GLchar * name);
extern void (AWGL_API* BlendEquationSeparate)(GLenum modeRGB, GLenum modeAlpha);
extern void (AWGL_API* CompileShader)(GLuint shader);
extern GLuint (AWGL_API* CreateProgram)(void);
extern GLuint (AWGL_API* CreateShader)(GLenum type);
extern void (AWGL_API* DeleteProgram)(GLuint program);
extern void (AWGL_API* DeleteShader)(GLuint shader);
extern void (AWGL_API* DetachShader)(GLuint program, GLuint shader);
extern void (AWGL_API* DisableVertexAttribArray)(GLuint index);
extern void (AWGL_API* DrawBuffers)(GLsizei n, const GLenum * bufs);
extern void (AWGL_API* EnableVertexAttribArray)(GLuint index);
extern void (AWGL_API* GetActiveAttrib)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
extern void (AWGL_API* GetActiveUniform)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
extern void (AWGL_API* GetAttachedShaders)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);
extern GLint (AWGL_API* GetAttribLocation)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetProgramInfoLog)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
extern void (AWGL_API* GetProgramiv)(GLuint program, GLenum pname, GLint * params);
extern void (AWGL_API* GetShaderInfoLog)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
extern void (AWGL_API* GetShaderSource)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
extern void (AWGL_API* GetShaderiv)(GLuint shader, GLenum pname, GLint * params);
extern GLint (AWGL_API* GetUniformLocation)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetUniformfv)(GLuint program, GLint location, GLfloat * params);
extern void (AWGL_API* GetUniformiv)(GLuint program, GLint location, GLint * params);
extern void (AWGL_API* GetVertexAttribPointerv)(GLuint index, GLenum pname, void ** pointer);
extern void (AWGL_API* GetVertexAttribdv)(GLuint index, GLenum pname, GLdouble * params);
extern void (AWGL_API* GetVertexAttribfv)(GLuint index, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetVertexAttribiv)(GLuint index, GLenum pname, GLint * params);
extern GLboolean (AWGL_API* IsProgram)(GLuint program);
extern GLboolean (AWGL_API* IsShader)(GLuint shader);
extern void (AWGL_API* LinkProgram)(GLuint program);
extern void (AWGL_API* ShaderSource)(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length);
extern void (AWGL_API* StencilFuncSeparate)(GLenum face, GLenum func, GLint ref, GLuint mask);
extern void (AWGL_API* StencilMaskSeparate)(GLenum face, GLuint mask);
extern void (AWGL_API* StencilOpSeparate)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern void (AWGL_API* Uniform1f)(GLint location, GLfloat v0);
extern void (AWGL_API* Uniform1fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform1i)(GLint location, GLint v0);
extern void (AWGL_API* Uniform1iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* Uniform2f)(GLint location, GLfloat v0, GLfloat v1);
extern void (AWGL_API* Uniform2fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform2i)(GLint location, GLint v0, GLint v1);
extern void (AWGL_API* Uniform2iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* Uniform3f)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void (AWGL_API* Uniform3fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform3i)(GLint location, GLint v0, GLint v1, GLint v2);
extern void (AWGL_API* Uniform3iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* Uniform4f)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void (AWGL_API* Uniform4fv)(GLint location, GLsizei count, const GLfloat * value);
extern void (AWGL_API* Uniform4i)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void (AWGL_API* Uniform4iv)(GLint location, GLsizei count, const GLint * value);
extern void (AWGL_API* UniformMatrix2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UseProgram)(GLuint program);
extern void (AWGL_API* ValidateProgram)(GLuint program);
extern void (AWGL_API* VertexAttrib1d)(GLuint index, GLdouble x);
extern void (AWGL_API* VertexAttrib1dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib1f)(GLuint index, GLfloat x);
extern void (AWGL_API* VertexAttrib1fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib1s)(GLuint index, GLshort x);
extern void (AWGL_API* VertexAttrib1sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib2d)(GLuint index, GLdouble x, GLdouble y);
extern void (AWGL_API* VertexAttrib2dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib2f)(GLuint index, GLfloat x, GLfloat y);
extern void (AWGL_API* VertexAttrib2fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib2s)(GLuint index, GLshort x, GLshort y);
extern void (AWGL_API* VertexAttrib2sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib3d)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void (AWGL_API* VertexAttrib3dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib3f)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void (AWGL_API* VertexAttrib3fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib3s)(GLuint index, GLshort x, GLshort y, GLshort z);
extern void (AWGL_API* VertexAttrib3sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib4Nbv)(GLuint index, const GLbyte * v);
extern void (AWGL_API* VertexAttrib4Niv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttrib4Nsv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib4Nub)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void (AWGL_API* VertexAttrib4Nubv)(GLuint index, const GLubyte * v);
extern void (AWGL_API* VertexAttrib4Nuiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttrib4Nusv)(GLuint index, const GLushort * v);
extern void (AWGL_API* VertexAttrib4bv)(GLuint index, const GLbyte * v);
extern void (AWGL_API* VertexAttrib4d)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void (AWGL_API* VertexAttrib4dv)(GLuint index, const GLdouble * v);
extern void (AWGL_API* VertexAttrib4f)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void (AWGL_API* VertexAttrib4fv)(GLuint index, const GLfloat * v);
extern void (AWGL_API* VertexAttrib4iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttrib4s)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void (AWGL_API* VertexAttrib4sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttrib4ubv)(GLuint index, const GLubyte * v);
extern void (AWGL_API* VertexAttrib4uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttrib4usv)(GLuint index, const GLushort * v);
extern void (AWGL_API* VertexAttribPointer)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);

/* gl version 2.1 */
extern void (AWGL_API* UniformMatrix2x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix2x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix3x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix3x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix4x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
extern void (AWGL_API* UniformMatrix4x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);

/* gl version 3.0 */
extern void (AWGL_API* BeginConditionalRender)(GLuint id, GLenum mode);
extern void (AWGL_API* BeginTransformFeedback)(GLenum primitiveMode);
extern void (AWGL_API* BindBufferBase)(GLenum target, GLuint index, GLuint buffer);
extern void (AWGL_API* BindBufferRange)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern void (AWGL_API* BindFragDataLocation)(GLuint program, GLuint color, const GLchar * name);
extern void (AWGL_API* BindFramebuffer)(GLenum target, GLuint framebuffer);
extern void (AWGL_API* BindRenderbuffer)(GLenum target, GLuint renderbuffer);
extern void (AWGL_API* BindVertexArray)(GLuint ren_array);
extern void (AWGL_API* BlitFramebuffer)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern GLenum (AWGL_API* CheckFramebufferStatus)(GLenum target);
extern void (AWGL_API* ClampColor)(GLenum target, GLenum clamp);
extern void (AWGL_API* ClearBufferfi)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
extern void (AWGL_API* ClearBufferfv)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
extern void (AWGL_API* ClearBufferiv)(GLenum buffer, GLint drawbuffer, const GLint * value);
extern void (AWGL_API* ClearBufferuiv)(GLenum buffer, GLint drawbuffer, const GLuint * value);
extern void (AWGL_API* ColorMaski)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern void (AWGL_API* DeleteFramebuffers)(GLsizei n, const GLuint * framebuffers);
extern void (AWGL_API* DeleteRenderbuffers)(GLsizei n, const GLuint * renderbuffers);
extern void (AWGL_API* DeleteVertexArrays)(GLsizei n, const GLuint * arrays);
extern void (AWGL_API* Disablei)(GLenum target, GLuint index);
extern void (AWGL_API* Enablei)(GLenum target, GLuint index);
extern void (AWGL_API* EndConditionalRender)(void);
extern void (AWGL_API* EndTransformFeedback)(void);
extern void (AWGL_API* FlushMappedBufferRange)(GLenum target, GLintptr offset, GLsizeiptr length);
extern void (AWGL_API* FramebufferRenderbuffer)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void (AWGL_API* FramebufferTexture1D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void (AWGL_API* FramebufferTexture2D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void (AWGL_API* FramebufferTexture3D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void (AWGL_API* FramebufferTextureLayer)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
extern void (AWGL_API* GenFramebuffers)(GLsizei n, GLuint * framebuffers);
extern void (AWGL_API* GenRenderbuffers)(GLsizei n, GLuint * renderbuffers);
extern void (AWGL_API* GenVertexArrays)(GLsizei n, GLuint * arrays);
extern void (AWGL_API* GenerateMipmap)(GLenum target);
extern void (AWGL_API* GetBooleani_v)(GLenum target, GLuint index, GLboolean * data);
extern GLint (AWGL_API* GetFragDataLocation)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetFramebufferAttachmentParameteriv)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
extern void (AWGL_API* GetIntegeri_v)(GLenum target, GLuint index, GLint * data);
extern void (AWGL_API* GetRenderbufferParameteriv)(GLenum target, GLenum pname, GLint * params);
extern const GLubyte * (AWGL_API* GetStringi)(GLenum name, GLuint index);
extern void (AWGL_API* GetTexParameterIiv)(GLenum target, GLenum pname, GLint * params);
extern void (AWGL_API* GetTexParameterIuiv)(GLenum target, GLenum pname, GLuint * params);
extern void (AWGL_API* GetTransformFeedbackVarying)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
extern void (AWGL_API* GetUniformuiv)(GLuint program, GLint location, GLuint * params);
extern void (AWGL_API* GetVertexAttribIiv)(GLuint index, GLenum pname, GLint * params);
extern void (AWGL_API* GetVertexAttribIuiv)(GLuint index, GLenum pname, GLuint * params);
extern GLboolean (AWGL_API* IsEnabledi)(GLenum target, GLuint index);
extern GLboolean (AWGL_API* IsFramebuffer)(GLuint framebuffer);
extern GLboolean (AWGL_API* IsRenderbuffer)(GLuint renderbuffer);
extern GLboolean (AWGL_API* IsVertexArray)(GLuint ren_array);
extern void * (AWGL_API* MapBufferRange)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
extern void (AWGL_API* RenderbufferStorage)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void (AWGL_API* RenderbufferStorageMultisample)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern void (AWGL_API* TexParameterIiv)(GLenum target, GLenum pname, const GLint * params);
extern void (AWGL_API* TexParameterIuiv)(GLenum target, GLenum pname, const GLuint * params);
extern void (AWGL_API* TransformFeedbackVaryings)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
extern void (AWGL_API* Uniform1ui)(GLint location, GLuint v0);
extern void (AWGL_API* Uniform1uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* Uniform2ui)(GLint location, GLuint v0, GLuint v1);
extern void (AWGL_API* Uniform2uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* Uniform3ui)(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern void (AWGL_API* Uniform3uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* Uniform4ui)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern void (AWGL_API* Uniform4uiv)(GLint location, GLsizei count, const GLuint * value);
extern void (AWGL_API* VertexAttribI1i)(GLuint index, GLint x);
extern void (AWGL_API* VertexAttribI1iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI1ui)(GLuint index, GLuint x);
extern void (AWGL_API* VertexAttribI1uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI2i)(GLuint index, GLint x, GLint y);
extern void (AWGL_API* VertexAttribI2iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI2ui)(GLuint index, GLuint x, GLuint y);
extern void (AWGL_API* VertexAttribI2uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI3i)(GLuint index, GLint x, GLint y, GLint z);
extern void (AWGL_API* VertexAttribI3iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI3ui)(GLuint index, GLuint x, GLuint y, GLuint z);
extern void (AWGL_API* VertexAttribI3uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI4bv)(GLuint index, const GLbyte * v);
extern void (AWGL_API* VertexAttribI4i)(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern void (AWGL_API* VertexAttribI4iv)(GLuint index, const GLint * v);
extern void (AWGL_API* VertexAttribI4sv)(GLuint index, const GLshort * v);
extern void (AWGL_API* VertexAttribI4ubv)(GLuint index, const GLubyte * v);
extern void (AWGL_API* VertexAttribI4ui)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern void (AWGL_API* VertexAttribI4uiv)(GLuint index, const GLuint * v);
extern void (AWGL_API* VertexAttribI4usv)(GLuint index, const GLushort * v);
extern void (AWGL_API* VertexAttribIPointer)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);

/* gl version 3.1 */
extern void (AWGL_API* CopyBufferSubData)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
extern void (AWGL_API* DrawArraysInstanced)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
extern void (AWGL_API* DrawElementsInstanced)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);
extern void (AWGL_API* GetActiveUniformBlockName)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
extern void (AWGL_API* GetActiveUniformBlockiv)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
extern void (AWGL_API* GetActiveUniformName)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
extern void (AWGL_API* GetActiveUniformsiv)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
extern GLuint (AWGL_API* GetUniformBlockIndex)(GLuint program, const GLchar * uniformBlockName);
extern void (AWGL_API* GetUniformIndices)(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices);
extern void (AWGL_API* PrimitiveRestartIndex)(GLuint index);
extern void (AWGL_API* TexBuffer)(GLenum target, GLenum internalformat, GLuint buffer);
extern void (AWGL_API* UniformBlockBinding)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);

/* gl version 3.2 */
extern GLenum (AWGL_API* ClientWaitSync)(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void (AWGL_API* DeleteSync)(GLsync sync);
extern void (AWGL_API* DrawElementsBaseVertex)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex);
extern void (AWGL_API* DrawElementsInstancedBaseVertex)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex);
extern void (AWGL_API* DrawRangeElementsBaseVertex)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex);
extern GLsync (AWGL_API* FenceSync)(GLenum condition, GLbitfield flags);
extern void (AWGL_API* FramebufferTexture)(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern void (AWGL_API* GetBufferParameteri64v)(GLenum target, GLenum pname, GLint64 * params);
extern void (AWGL_API* GetInteger64i_v)(GLenum target, GLuint index, GLint64 * data);
extern void (AWGL_API* GetInteger64v)(GLenum pname, GLint64 * data);
extern void (AWGL_API* GetMultisamplefv)(GLenum pname, GLuint index, GLfloat * val);
extern void (AWGL_API* GetSynciv)(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values);
extern GLboolean (AWGL_API* IsSync)(GLsync sync);
extern void (AWGL_API* MultiDrawElementsBaseVertex)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex);
extern void (AWGL_API* ProvokingVertex)(GLenum mode);
extern void (AWGL_API* SampleMaski)(GLuint maskNumber, GLbitfield mask);
extern void (AWGL_API* TexImage2DMultisample)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
extern void (AWGL_API* TexImage3DMultisample)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
extern void (AWGL_API* WaitSync)(GLsync sync, GLbitfield flags, GLuint64 timeout);

/* gl version 3.3 */
extern void (AWGL_API* BindFragDataLocationIndexed)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
extern void (AWGL_API* BindSampler)(GLuint unit, GLuint sampler);
extern void (AWGL_API* DeleteSamplers)(GLsizei count, const GLuint * samplers);
extern void (AWGL_API* GenSamplers)(GLsizei count, GLuint * samplers);
extern GLint (AWGL_API* GetFragDataIndex)(GLuint program, const GLchar * name);
extern void (AWGL_API* GetQueryObjecti64v)(GLuint id, GLenum pname, GLint64 * params);
extern void (AWGL_API* GetQueryObjectui64v)(GLuint id, GLenum pname, GLuint64 * params);
extern void (AWGL_API* GetSamplerParameterIiv)(GLuint sampler, GLenum pname, GLint * params);
extern void (AWGL_API* GetSamplerParameterIuiv)(GLuint sampler, GLenum pname, GLuint * params);
extern void (AWGL_API* GetSamplerParameterfv)(GLuint sampler, GLenum pname, GLfloat * params);
extern void (AWGL_API* GetSamplerParameteriv)(GLuint sampler, GLenum pname, GLint * params);
extern GLboolean (AWGL_API* IsSampler)(GLuint sampler);
extern void (AWGL_API* QueryCounter)(GLuint id, GLenum target);
extern void (AWGL_API* SamplerParameterIiv)(GLuint sampler, GLenum pname, const GLint * param);
extern void (AWGL_API* SamplerParameterIuiv)(GLuint sampler, GLenum pname, const GLuint * param);
extern void (AWGL_API* SamplerParameterf)(GLuint sampler, GLenum pname, GLfloat param);
extern void (AWGL_API* SamplerParameterfv)(GLuint sampler, GLenum pname, const GLfloat * param);
extern void (AWGL_API* SamplerParameteri)(GLuint sampler, GLenum pname, GLint param);
extern void (AWGL_API* SamplerParameteriv)(GLuint sampler, GLenum pname, const GLint * param);
extern void (AWGL_API* VertexAttribDivisor)(GLuint index, GLuint divisor);
extern void (AWGL_API* VertexAttribP1ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP1uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
extern void (AWGL_API* VertexAttribP2ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP2uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
extern void (AWGL_API* VertexAttribP3ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP3uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
extern void (AWGL_API* VertexAttribP4ui)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
extern void (AWGL_API* VertexAttribP4uiv)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);

} //namespace _impl

/* gl version 1.0 */
inline void blend_func(GLenum sfactor, GLenum dfactor)
{
	_impl::BlendFunc(sfactor, dfactor);
}
inline void clear(GLbitfield mask)
{
	_impl::Clear(mask);
}
inline void clear_color(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	_impl::ClearColor(red, green, blue, alpha);
}
inline void clear_depth(GLdouble depth)
{
	_impl::ClearDepth(depth);
}
inline void clear_stencil(GLint s)
{
	_impl::ClearStencil(s);
}
inline void color_mask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	_impl::ColorMask(red, green, blue, alpha);
}
inline void cull_face(GLenum mode)
{
	_impl::CullFace(mode);
}
inline void depth_func(GLenum func)
{
	_impl::DepthFunc(func);
}
inline void depth_mask(GLboolean flag)
{
	_impl::DepthMask(flag);
}
inline void depth_range(GLdouble ren_near, GLdouble ren_far)
{
	_impl::DepthRange(ren_near, ren_far);
}
inline void disable(GLenum cap)
{
	_impl::Disable(cap);
}
inline void draw_buffer(GLenum buf)
{
	_impl::DrawBuffer(buf);
}
inline void enable(GLenum cap)
{
	_impl::Enable(cap);
}
inline void finish(void)
{
	_impl::Finish();
}
inline void flush(void)
{
	_impl::Flush();
}
inline void front_face(GLenum mode)
{
	_impl::FrontFace(mode);
}
inline void get_booleanv(GLenum pname, GLboolean * data)
{
	_impl::GetBooleanv(pname, data);
}
inline void get_doublev(GLenum pname, GLdouble * data)
{
	_impl::GetDoublev(pname, data);
}
inline GLenum get_error(void)
{
	return _impl::GetError();
}
inline void get_floatv(GLenum pname, GLfloat * data)
{
	_impl::GetFloatv(pname, data);
}
inline void get_integerv(GLenum pname, GLint * data)
{
	_impl::GetIntegerv(pname, data);
}
inline const GLubyte * get_string(GLenum name)
{
	return _impl::GetString(name);
}
inline void get_tex_image(GLenum target, GLint level, GLenum format, GLenum type, void * pixels)
{
	_impl::GetTexImage(target, level, format, type, pixels);
}
inline void get_tex_level_parameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)
{
	_impl::GetTexLevelParameterfv(target, level, pname, params);
}
inline void get_tex_level_parameteriv(GLenum target, GLint level, GLenum pname, GLint * params)
{
	_impl::GetTexLevelParameteriv(target, level, pname, params);
}
inline void get_tex_parameterfv(GLenum target, GLenum pname, GLfloat * params)
{
	_impl::GetTexParameterfv(target, pname, params);
}
inline void get_tex_parameteriv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetTexParameteriv(target, pname, params);
}
inline void hint(GLenum target, GLenum mode)
{
	_impl::Hint(target, mode);
}
inline GLboolean is_enabled(GLenum cap)
{
	return _impl::IsEnabled(cap);
}
inline void line_width(GLfloat width)
{
	_impl::LineWidth(width);
}
inline void logic_op(GLenum opcode)
{
	_impl::LogicOp(opcode);
}
inline void pixel_storef(GLenum pname, GLfloat param)
{
	_impl::PixelStoref(pname, param);
}
inline void pixel_storei(GLenum pname, GLint param)
{
	_impl::PixelStorei(pname, param);
}
inline void point_size(GLfloat size)
{
	_impl::PointSize(size);
}
inline void polygon_mode(GLenum face, GLenum mode)
{
	_impl::PolygonMode(face, mode);
}
inline void read_buffer(GLenum src)
{
	_impl::ReadBuffer(src);
}
inline void read_pixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)
{
	_impl::ReadPixels(x, y, width, height, format, type, pixels);
}
inline void scissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::Scissor(x, y, width, height);
}
inline void stencil_func(GLenum func, GLint ref, GLuint mask)
{
	_impl::StencilFunc(func, ref, mask);
}
inline void stencil_mask(GLuint mask)
{
	_impl::StencilMask(mask);
}
inline void stencil_op(GLenum fail, GLenum zfail, GLenum zpass)
{
	_impl::StencilOp(fail, zfail, zpass);
}
inline void tex_image1_d(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexImage1D(target, level, internalformat, width, border, format, type, pixels);
}
inline void tex_image2_d(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}
inline void tex_parameterf(GLenum target, GLenum pname, GLfloat param)
{
	_impl::TexParameterf(target, pname, param);
}
inline void tex_parameterfv(GLenum target, GLenum pname, const GLfloat * params)
{
	_impl::TexParameterfv(target, pname, params);
}
inline void tex_parameteri(GLenum target, GLenum pname, GLint param)
{
	_impl::TexParameteri(target, pname, param);
}
inline void tex_parameteriv(GLenum target, GLenum pname, const GLint * params)
{
	_impl::TexParameteriv(target, pname, params);
}
inline void viewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::Viewport(x, y, width, height);
}

/* gl version 1.1 */
inline void bind_texture(GLenum target, GLuint texture)
{
	_impl::BindTexture(target, texture);
}
inline void copy_tex_image1_d(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
	_impl::CopyTexImage1D(target, level, internalformat, x, y, width, border);
}
inline void copy_tex_image2_d(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	_impl::CopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}
inline void copy_tex_sub_image1_d(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
	_impl::CopyTexSubImage1D(target, level, xoffset, x, y, width);
}
inline void copy_tex_sub_image2_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}
inline void delete_textures(GLsizei n, const GLuint * textures)
{
	_impl::DeleteTextures(n, textures);
}
inline void draw_arrays(GLenum mode, GLint first, GLsizei count)
{
	_impl::DrawArrays(mode, first, count);
}
inline void draw_elements(GLenum mode, GLsizei count, GLenum type, const void * indices)
{
	_impl::DrawElements(mode, count, type, indices);
}
inline void gen_textures(GLsizei n, GLuint * textures)
{
	_impl::GenTextures(n, textures);
}
inline GLboolean is_texture(GLuint texture)
{
	return _impl::IsTexture(texture);
}
inline void polygon_offset(GLfloat factor, GLfloat units)
{
	_impl::PolygonOffset(factor, units);
}
inline void tex_sub_image1_d(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexSubImage1D(target, level, xoffset, width, format, type, pixels);
}
inline void tex_sub_image2_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

/* gl version 1.2 */
inline void copy_tex_sub_image3_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	_impl::CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}
inline void draw_range_elements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)
{
	_impl::DrawRangeElements(mode, start, end, count, type, indices);
}
inline void tex_image3_d(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}
inline void tex_sub_image3_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
	_impl::TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

/* gl version 1.3 */
inline void active_texture(GLenum texture)
{
	_impl::ActiveTexture(texture);
}
inline void compressed_tex_image1_d(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
}
inline void compressed_tex_image2_d(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}
inline void compressed_tex_image3_d(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}
inline void compressed_tex_sub_image1_d(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
}
inline void compressed_tex_sub_image2_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}
inline void compressed_tex_sub_image3_d(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)
{
	_impl::CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}
inline void get_compressed_tex_image(GLenum target, GLint level, void * img)
{
	_impl::GetCompressedTexImage(target, level, img);
}
inline void sample_coverage(GLfloat value, GLboolean invert)
{
	_impl::SampleCoverage(value, invert);
}

/* gl version 1.4 */
inline void blend_color(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	_impl::BlendColor(red, green, blue, alpha);
}
inline void blend_equation(GLenum mode)
{
	_impl::BlendEquation(mode);
}
inline void blend_func_separate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
	_impl::BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}
inline void multi_draw_arrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount)
{
	_impl::MultiDrawArrays(mode, first, count, drawcount);
}
inline void multi_draw_elements(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount)
{
	_impl::MultiDrawElements(mode, count, type, indices, drawcount);
}
inline void point_parameterf(GLenum pname, GLfloat param)
{
	_impl::PointParameterf(pname, param);
}
inline void point_parameterfv(GLenum pname, const GLfloat * params)
{
	_impl::PointParameterfv(pname, params);
}
inline void point_parameteri(GLenum pname, GLint param)
{
	_impl::PointParameteri(pname, param);
}
inline void point_parameteriv(GLenum pname, const GLint * params)
{
	_impl::PointParameteriv(pname, params);
}

/* gl version 1.5 */
inline void begin_query(GLenum target, GLuint id)
{
	_impl::BeginQuery(target, id);
}
inline void bind_buffer(GLenum target, GLuint buffer)
{
	_impl::BindBuffer(target, buffer);
}
inline void buffer_data(GLenum target, GLsizeiptr size, const void * data, GLenum usage)
{
	_impl::BufferData(target, size, data, usage);
}
inline void buffer_sub_data(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)
{
	_impl::BufferSubData(target, offset, size, data);
}
inline void delete_buffers(GLsizei n, const GLuint * buffers)
{
	_impl::DeleteBuffers(n, buffers);
}
inline void delete_queries(GLsizei n, const GLuint * ids)
{
	_impl::DeleteQueries(n, ids);
}
inline void end_query(GLenum target)
{
	_impl::EndQuery(target);
}
inline void gen_buffers(GLsizei n, GLuint * buffers)
{
	_impl::GenBuffers(n, buffers);
}
inline void gen_queries(GLsizei n, GLuint * ids)
{
	_impl::GenQueries(n, ids);
}
inline void get_buffer_parameteriv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetBufferParameteriv(target, pname, params);
}
inline void get_buffer_pointerv(GLenum target, GLenum pname, void ** params)
{
	_impl::GetBufferPointerv(target, pname, params);
}
inline void get_buffer_sub_data(GLenum target, GLintptr offset, GLsizeiptr size, void * data)
{
	_impl::GetBufferSubData(target, offset, size, data);
}
inline void get_query_objectiv(GLuint id, GLenum pname, GLint * params)
{
	_impl::GetQueryObjectiv(id, pname, params);
}
inline void get_query_objectuiv(GLuint id, GLenum pname, GLuint * params)
{
	_impl::GetQueryObjectuiv(id, pname, params);
}
inline void get_queryiv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetQueryiv(target, pname, params);
}
inline GLboolean is_buffer(GLuint buffer)
{
	return _impl::IsBuffer(buffer);
}
inline GLboolean is_query(GLuint id)
{
	return _impl::IsQuery(id);
}
inline void * map_buffer(GLenum target, GLenum access)
{
	return _impl::MapBuffer(target, access);
}
inline GLboolean unmap_buffer(GLenum target)
{
	return _impl::UnmapBuffer(target);
}

/* gl version 2.0 */
inline void attach_shader(GLuint program, GLuint shader)
{
	_impl::AttachShader(program, shader);
}
inline void bind_attrib_location(GLuint program, GLuint index, const GLchar * name)
{
	_impl::BindAttribLocation(program, index, name);
}
inline void blend_equation_separate(GLenum modeRGB, GLenum modeAlpha)
{
	_impl::BlendEquationSeparate(modeRGB, modeAlpha);
}
inline void compile_shader(GLuint shader)
{
	_impl::CompileShader(shader);
}
inline GLuint create_program(void)
{
	return _impl::CreateProgram();
}
inline GLuint create_shader(GLenum type)
{
	return _impl::CreateShader(type);
}
inline void delete_program(GLuint program)
{
	_impl::DeleteProgram(program);
}
inline void delete_shader(GLuint shader)
{
	_impl::DeleteShader(shader);
}
inline void detach_shader(GLuint program, GLuint shader)
{
	_impl::DetachShader(program, shader);
}
inline void disable_vertex_attrib_array(GLuint index)
{
	_impl::DisableVertexAttribArray(index);
}
inline void draw_buffers(GLsizei n, const GLenum * bufs)
{
	_impl::DrawBuffers(n, bufs);
}
inline void enable_vertex_attrib_array(GLuint index)
{
	_impl::EnableVertexAttribArray(index);
}
inline void get_active_attrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	_impl::GetActiveAttrib(program, index, bufSize, length, size, type, name);
}
inline void get_active_uniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	_impl::GetActiveUniform(program, index, bufSize, length, size, type, name);
}
inline void get_attached_shaders(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders)
{
	_impl::GetAttachedShaders(program, maxCount, count, shaders);
}
inline GLint get_attrib_location(GLuint program, const GLchar * name)
{
	return _impl::GetAttribLocation(program, name);
}
inline void get_program_info_log(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	_impl::GetProgramInfoLog(program, bufSize, length, infoLog);
}
inline void get_programiv(GLuint program, GLenum pname, GLint * params)
{
	_impl::GetProgramiv(program, pname, params);
}
inline void get_shader_info_log(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	_impl::GetShaderInfoLog(shader, bufSize, length, infoLog);
}
inline void get_shader_source(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source)
{
	_impl::GetShaderSource(shader, bufSize, length, source);
}
inline void get_shaderiv(GLuint shader, GLenum pname, GLint * params)
{
	_impl::GetShaderiv(shader, pname, params);
}
inline GLint get_uniform_location(GLuint program, const GLchar * name)
{
	return _impl::GetUniformLocation(program, name);
}
inline void get_uniformfv(GLuint program, GLint location, GLfloat * params)
{
	_impl::GetUniformfv(program, location, params);
}
inline void get_uniformiv(GLuint program, GLint location, GLint * params)
{
	_impl::GetUniformiv(program, location, params);
}
inline void get_vertex_attrib_pointerv(GLuint index, GLenum pname, void ** pointer)
{
	_impl::GetVertexAttribPointerv(index, pname, pointer);
}
inline void get_vertex_attribdv(GLuint index, GLenum pname, GLdouble * params)
{
	_impl::GetVertexAttribdv(index, pname, params);
}
inline void get_vertex_attribfv(GLuint index, GLenum pname, GLfloat * params)
{
	_impl::GetVertexAttribfv(index, pname, params);
}
inline void get_vertex_attribiv(GLuint index, GLenum pname, GLint * params)
{
	_impl::GetVertexAttribiv(index, pname, params);
}
inline GLboolean is_program(GLuint program)
{
	return _impl::IsProgram(program);
}
inline GLboolean is_shader(GLuint shader)
{
	return _impl::IsShader(shader);
}
inline void link_program(GLuint program)
{
	_impl::LinkProgram(program);
}
inline void shader_source(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length)
{
	_impl::ShaderSource(shader, count, string, length);
}
inline void stencil_func_separate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
	_impl::StencilFuncSeparate(face, func, ref, mask);
}
inline void stencil_mask_separate(GLenum face, GLuint mask)
{
	_impl::StencilMaskSeparate(face, mask);
}
inline void stencil_op_separate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
	_impl::StencilOpSeparate(face, sfail, dpfail, dppass);
}
inline void uniform1f(GLint location, GLfloat v0)
{
	_impl::Uniform1f(location, v0);
}
inline void uniform1fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform1fv(location, count, value);
}
inline void uniform1i(GLint location, GLint v0)
{
	_impl::Uniform1i(location, v0);
}
inline void uniform1iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform1iv(location, count, value);
}
inline void uniform2f(GLint location, GLfloat v0, GLfloat v1)
{
	_impl::Uniform2f(location, v0, v1);
}
inline void uniform2fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform2fv(location, count, value);
}
inline void uniform2i(GLint location, GLint v0, GLint v1)
{
	_impl::Uniform2i(location, v0, v1);
}
inline void uniform2iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform2iv(location, count, value);
}
inline void uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
	_impl::Uniform3f(location, v0, v1, v2);
}
inline void uniform3fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform3fv(location, count, value);
}
inline void uniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
	_impl::Uniform3i(location, v0, v1, v2);
}
inline void uniform3iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform3iv(location, count, value);
}
inline void uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
	_impl::Uniform4f(location, v0, v1, v2, v3);
}
inline void uniform4fv(GLint location, GLsizei count, const GLfloat * value)
{
	_impl::Uniform4fv(location, count, value);
}
inline void uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
	_impl::Uniform4i(location, v0, v1, v2, v3);
}
inline void uniform4iv(GLint location, GLsizei count, const GLint * value)
{
	_impl::Uniform4iv(location, count, value);
}
inline void uniform_matrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix2fv(location, count, transpose, value);
}
inline void uniform_matrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix3fv(location, count, transpose, value);
}
inline void uniform_matrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix4fv(location, count, transpose, value);
}
inline void use_program(GLuint program)
{
	_impl::UseProgram(program);
}
inline void validate_program(GLuint program)
{
	_impl::ValidateProgram(program);
}
inline void vertex_attrib1d(GLuint index, GLdouble x)
{
	_impl::VertexAttrib1d(index, x);
}
inline void vertex_attrib1dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib1dv(index, v);
}
inline void vertex_attrib1f(GLuint index, GLfloat x)
{
	_impl::VertexAttrib1f(index, x);
}
inline void vertex_attrib1fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib1fv(index, v);
}
inline void vertex_attrib1s(GLuint index, GLshort x)
{
	_impl::VertexAttrib1s(index, x);
}
inline void vertex_attrib1sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib1sv(index, v);
}
inline void vertex_attrib2d(GLuint index, GLdouble x, GLdouble y)
{
	_impl::VertexAttrib2d(index, x, y);
}
inline void vertex_attrib2dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib2dv(index, v);
}
inline void vertex_attrib2f(GLuint index, GLfloat x, GLfloat y)
{
	_impl::VertexAttrib2f(index, x, y);
}
inline void vertex_attrib2fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib2fv(index, v);
}
inline void vertex_attrib2s(GLuint index, GLshort x, GLshort y)
{
	_impl::VertexAttrib2s(index, x, y);
}
inline void vertex_attrib2sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib2sv(index, v);
}
inline void vertex_attrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
	_impl::VertexAttrib3d(index, x, y, z);
}
inline void vertex_attrib3dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib3dv(index, v);
}
inline void vertex_attrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
	_impl::VertexAttrib3f(index, x, y, z);
}
inline void vertex_attrib3fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib3fv(index, v);
}
inline void vertex_attrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
	_impl::VertexAttrib3s(index, x, y, z);
}
inline void vertex_attrib3sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib3sv(index, v);
}
inline void vertex_attrib4_nbv(GLuint index, const GLbyte * v)
{
	_impl::VertexAttrib4Nbv(index, v);
}
inline void vertex_attrib4_niv(GLuint index, const GLint * v)
{
	_impl::VertexAttrib4Niv(index, v);
}
inline void vertex_attrib4_nsv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib4Nsv(index, v);
}
inline void vertex_attrib4_nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
	_impl::VertexAttrib4Nub(index, x, y, z, w);
}
inline void vertex_attrib4_nubv(GLuint index, const GLubyte * v)
{
	_impl::VertexAttrib4Nubv(index, v);
}
inline void vertex_attrib4_nuiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttrib4Nuiv(index, v);
}
inline void vertex_attrib4_nusv(GLuint index, const GLushort * v)
{
	_impl::VertexAttrib4Nusv(index, v);
}
inline void vertex_attrib4bv(GLuint index, const GLbyte * v)
{
	_impl::VertexAttrib4bv(index, v);
}
inline void vertex_attrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	_impl::VertexAttrib4d(index, x, y, z, w);
}
inline void vertex_attrib4dv(GLuint index, const GLdouble * v)
{
	_impl::VertexAttrib4dv(index, v);
}
inline void vertex_attrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	_impl::VertexAttrib4f(index, x, y, z, w);
}
inline void vertex_attrib4fv(GLuint index, const GLfloat * v)
{
	_impl::VertexAttrib4fv(index, v);
}
inline void vertex_attrib4iv(GLuint index, const GLint * v)
{
	_impl::VertexAttrib4iv(index, v);
}
inline void vertex_attrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
	_impl::VertexAttrib4s(index, x, y, z, w);
}
inline void vertex_attrib4sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttrib4sv(index, v);
}
inline void vertex_attrib4ubv(GLuint index, const GLubyte * v)
{
	_impl::VertexAttrib4ubv(index, v);
}
inline void vertex_attrib4uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttrib4uiv(index, v);
}
inline void vertex_attrib4usv(GLuint index, const GLushort * v)
{
	_impl::VertexAttrib4usv(index, v);
}
inline void vertex_attrib_pointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, uintptr_t pointer)
{
	_impl::VertexAttribPointer(index, size, type, normalized, stride, (const void*)pointer);
}

/* gl version 2.1 */
inline void uniform_matrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix2x3fv(location, count, transpose, value);
}
inline void uniform_matrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix2x4fv(location, count, transpose, value);
}
inline void uniform_matrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix3x2fv(location, count, transpose, value);
}
inline void uniform_matrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix3x4fv(location, count, transpose, value);
}
inline void uniform_matrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix4x2fv(location, count, transpose, value);
}
inline void uniform_matrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	_impl::UniformMatrix4x3fv(location, count, transpose, value);
}

/* gl version 3.0 */
inline void begin_conditional_render(GLuint id, GLenum mode)
{
	_impl::BeginConditionalRender(id, mode);
}
inline void begin_transform_feedback(GLenum primitiveMode)
{
	_impl::BeginTransformFeedback(primitiveMode);
}
inline void bind_buffer_base(GLenum target, GLuint index, GLuint buffer)
{
	_impl::BindBufferBase(target, index, buffer);
}
inline void bind_buffer_range(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	_impl::BindBufferRange(target, index, buffer, offset, size);
}
inline void bind_frag_data_location(GLuint program, GLuint color, const GLchar * name)
{
	_impl::BindFragDataLocation(program, color, name);
}
inline void bind_framebuffer(GLenum target, GLuint framebuffer)
{
	_impl::BindFramebuffer(target, framebuffer);
}
inline void bind_renderbuffer(GLenum target, GLuint renderbuffer)
{
	_impl::BindRenderbuffer(target, renderbuffer);
}
inline void bind_vertex_array(GLuint ren_array)
{
	_impl::BindVertexArray(ren_array);
}
inline void blit_framebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
	_impl::BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}
inline GLenum check_framebuffer_status(GLenum target)
{
	return _impl::CheckFramebufferStatus(target);
}
inline void clamp_color(GLenum target, GLenum clamp)
{
	_impl::ClampColor(target, clamp);
}
inline void clear_bufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
	_impl::ClearBufferfi(buffer, drawbuffer, depth, stencil);
}
inline void clear_bufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value)
{
	_impl::ClearBufferfv(buffer, drawbuffer, value);
}
inline void clear_bufferiv(GLenum buffer, GLint drawbuffer, const GLint * value)
{
	_impl::ClearBufferiv(buffer, drawbuffer, value);
}
inline void clear_bufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value)
{
	_impl::ClearBufferuiv(buffer, drawbuffer, value);
}
inline void color_maski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
	_impl::ColorMaski(index, r, g, b, a);
}
inline void delete_framebuffers(GLsizei n, const GLuint * framebuffers)
{
	_impl::DeleteFramebuffers(n, framebuffers);
}
inline void delete_renderbuffers(GLsizei n, const GLuint * renderbuffers)
{
	_impl::DeleteRenderbuffers(n, renderbuffers);
}
inline void delete_vertex_arrays(GLsizei n, const GLuint * arrays)
{
	_impl::DeleteVertexArrays(n, arrays);
}
inline void disablei(GLenum target, GLuint index)
{
	_impl::Disablei(target, index);
}
inline void enablei(GLenum target, GLuint index)
{
	_impl::Enablei(target, index);
}
inline void end_conditional_render(void)
{
	_impl::EndConditionalRender();
}
inline void end_transform_feedback(void)
{
	_impl::EndTransformFeedback();
}
inline void flush_mapped_buffer_range(GLenum target, GLintptr offset, GLsizeiptr length)
{
	_impl::FlushMappedBufferRange(target, offset, length);
}
inline void framebuffer_renderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	_impl::FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}
inline void framebuffer_texture1_d(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	_impl::FramebufferTexture1D(target, attachment, textarget, texture, level);
}
inline void framebuffer_texture2_d(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	_impl::FramebufferTexture2D(target, attachment, textarget, texture, level);
}
inline void framebuffer_texture3_d(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
	_impl::FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
}
inline void framebuffer_texture_layer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
	_impl::FramebufferTextureLayer(target, attachment, texture, level, layer);
}
inline void gen_framebuffers(GLsizei n, GLuint * framebuffers)
{
	_impl::GenFramebuffers(n, framebuffers);
}
inline void gen_renderbuffers(GLsizei n, GLuint * renderbuffers)
{
	_impl::GenRenderbuffers(n, renderbuffers);
}
inline void gen_vertex_arrays(GLsizei n, GLuint * arrays)
{
	_impl::GenVertexArrays(n, arrays);
}
inline void generate_mipmap(GLenum target)
{
	_impl::GenerateMipmap(target);
}
inline void get_booleani_v(GLenum target, GLuint index, GLboolean * data)
{
	_impl::GetBooleani_v(target, index, data);
}
inline GLint get_frag_data_location(GLuint program, const GLchar * name)
{
	return _impl::GetFragDataLocation(program, name);
}
inline void get_framebuffer_attachment_parameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params)
{
	_impl::GetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}
inline void get_integeri_v(GLenum target, GLuint index, GLint * data)
{
	_impl::GetIntegeri_v(target, index, data);
}
inline void get_renderbuffer_parameteriv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetRenderbufferParameteriv(target, pname, params);
}
inline const GLubyte * get_stringi(GLenum name, GLuint index)
{
	return _impl::GetStringi(name, index);
}
inline void get_tex_parameter_iiv(GLenum target, GLenum pname, GLint * params)
{
	_impl::GetTexParameterIiv(target, pname, params);
}
inline void get_tex_parameter_iuiv(GLenum target, GLenum pname, GLuint * params)
{
	_impl::GetTexParameterIuiv(target, pname, params);
}
inline void get_transform_feedback_varying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name)
{
	_impl::GetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
}
inline void get_uniformuiv(GLuint program, GLint location, GLuint * params)
{
	_impl::GetUniformuiv(program, location, params);
}
inline void get_vertex_attrib_iiv(GLuint index, GLenum pname, GLint * params)
{
	_impl::GetVertexAttribIiv(index, pname, params);
}
inline void get_vertex_attrib_iuiv(GLuint index, GLenum pname, GLuint * params)
{
	_impl::GetVertexAttribIuiv(index, pname, params);
}
inline GLboolean is_enabledi(GLenum target, GLuint index)
{
	return _impl::IsEnabledi(target, index);
}
inline GLboolean is_framebuffer(GLuint framebuffer)
{
	return _impl::IsFramebuffer(framebuffer);
}
inline GLboolean is_renderbuffer(GLuint renderbuffer)
{
	return _impl::IsRenderbuffer(renderbuffer);
}
inline GLboolean is_vertex_array(GLuint ren_array)
{
	return _impl::IsVertexArray(ren_array);
}
inline void * map_buffer_range(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
	return _impl::MapBufferRange(target, offset, length, access);
}
inline void renderbuffer_storage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	_impl::RenderbufferStorage(target, internalformat, width, height);
}
inline void renderbuffer_storage_multisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	_impl::RenderbufferStorageMultisample(target, samples, internalformat, width, height);
}
inline void tex_parameter_iiv(GLenum target, GLenum pname, const GLint * params)
{
	_impl::TexParameterIiv(target, pname, params);
}
inline void tex_parameter_iuiv(GLenum target, GLenum pname, const GLuint * params)
{
	_impl::TexParameterIuiv(target, pname, params);
}
inline void transform_feedback_varyings(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode)
{
	_impl::TransformFeedbackVaryings(program, count, varyings, bufferMode);
}
inline void uniform1ui(GLint location, GLuint v0)
{
	_impl::Uniform1ui(location, v0);
}
inline void uniform1uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform1uiv(location, count, value);
}
inline void uniform2ui(GLint location, GLuint v0, GLuint v1)
{
	_impl::Uniform2ui(location, v0, v1);
}
inline void uniform2uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform2uiv(location, count, value);
}
inline void uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
	_impl::Uniform3ui(location, v0, v1, v2);
}
inline void uniform3uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform3uiv(location, count, value);
}
inline void uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
	_impl::Uniform4ui(location, v0, v1, v2, v3);
}
inline void uniform4uiv(GLint location, GLsizei count, const GLuint * value)
{
	_impl::Uniform4uiv(location, count, value);
}
inline void vertex_attrib_i1i(GLuint index, GLint x)
{
	_impl::VertexAttribI1i(index, x);
}
inline void vertex_attrib_i1iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI1iv(index, v);
}
inline void vertex_attrib_i1ui(GLuint index, GLuint x)
{
	_impl::VertexAttribI1ui(index, x);
}
inline void vertex_attrib_i1uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI1uiv(index, v);
}
inline void vertex_attrib_i2i(GLuint index, GLint x, GLint y)
{
	_impl::VertexAttribI2i(index, x, y);
}
inline void vertex_attrib_i2iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI2iv(index, v);
}
inline void vertex_attrib_i2ui(GLuint index, GLuint x, GLuint y)
{
	_impl::VertexAttribI2ui(index, x, y);
}
inline void vertex_attrib_i2uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI2uiv(index, v);
}
inline void vertex_attrib_i3i(GLuint index, GLint x, GLint y, GLint z)
{
	_impl::VertexAttribI3i(index, x, y, z);
}
inline void vertex_attrib_i3iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI3iv(index, v);
}
inline void vertex_attrib_i3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
	_impl::VertexAttribI3ui(index, x, y, z);
}
inline void vertex_attrib_i3uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI3uiv(index, v);
}
inline void vertex_attrib_i4bv(GLuint index, const GLbyte * v)
{
	_impl::VertexAttribI4bv(index, v);
}
inline void vertex_attrib_i4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
	_impl::VertexAttribI4i(index, x, y, z, w);
}
inline void vertex_attrib_i4iv(GLuint index, const GLint * v)
{
	_impl::VertexAttribI4iv(index, v);
}
inline void vertex_attrib_i4sv(GLuint index, const GLshort * v)
{
	_impl::VertexAttribI4sv(index, v);
}
inline void vertex_attrib_i4ubv(GLuint index, const GLubyte * v)
{
	_impl::VertexAttribI4ubv(index, v);
}
inline void vertex_attrib_i4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
	_impl::VertexAttribI4ui(index, x, y, z, w);
}
inline void vertex_attrib_i4uiv(GLuint index, const GLuint * v)
{
	_impl::VertexAttribI4uiv(index, v);
}
inline void vertex_attrib_i4usv(GLuint index, const GLushort * v)
{
	_impl::VertexAttribI4usv(index, v);
}
inline void vertex_attrib_i_pointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
	_impl::VertexAttribIPointer(index, size, type, stride, pointer);
}

/* gl version 3.1 */
inline void copy_buffer_sub_data(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
	_impl::CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
}
inline void draw_arrays_instanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)
{
	_impl::DrawArraysInstanced(mode, first, count, instancecount);
}
inline void draw_elements_instanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount)
{
	_impl::DrawElementsInstanced(mode, count, type, indices, instancecount);
}
inline void get_active_uniform_block_name(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName)
{
	_impl::GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}
inline void get_active_uniform_blockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params)
{
	_impl::GetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}
inline void get_active_uniform_name(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName)
{
	_impl::GetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
}
inline void get_active_uniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params)
{
	_impl::GetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
}
inline GLuint get_uniform_block_index(GLuint program, const GLchar * uniformBlockName)
{
	return _impl::GetUniformBlockIndex(program, uniformBlockName);
}
inline void get_uniform_indices(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices)
{
	_impl::GetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}
inline void primitive_restart_index(GLuint index)
{
	_impl::PrimitiveRestartIndex(index);
}
inline void tex_buffer(GLenum target, GLenum internalformat, GLuint buffer)
{
	_impl::TexBuffer(target, internalformat, buffer);
}
inline void uniform_block_binding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
	_impl::UniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}

/* gl version 3.2 */
inline GLenum client_wait_sync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
	return _impl::ClientWaitSync(sync, flags, timeout);
}
inline void delete_sync(GLsync sync)
{
	_impl::DeleteSync(sync);
}
inline void draw_elements_base_vertex(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
	_impl::DrawElementsBaseVertex(mode, count, type, indices, basevertex);
}
inline void draw_elements_instanced_base_vertex(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex)
{
	_impl::DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
}
inline void draw_range_elements_base_vertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
	_impl::DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
}
inline GLsync fence_sync(GLenum condition, GLbitfield flags)
{
	return _impl::FenceSync(condition, flags);
}
inline void framebuffer_texture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
	_impl::FramebufferTexture(target, attachment, texture, level);
}
inline void get_buffer_parameteri64v(GLenum target, GLenum pname, GLint64 * params)
{
	_impl::GetBufferParameteri64v(target, pname, params);
}
inline void get_integer64i_v(GLenum target, GLuint index, GLint64 * data)
{
	_impl::GetInteger64i_v(target, index, data);
}
inline void get_integer64v(GLenum pname, GLint64 * data)
{
	_impl::GetInteger64v(pname, data);
}
inline void get_multisamplefv(GLenum pname, GLuint index, GLfloat * val)
{
	_impl::GetMultisamplefv(pname, index, val);
}
inline void get_synciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values)
{
	_impl::GetSynciv(sync, pname, bufSize, length, values);
}
inline GLboolean is_sync(GLsync sync)
{
	return _impl::IsSync(sync);
}
inline void multi_draw_elements_base_vertex(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex)
{
	_impl::MultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);
}
inline void provoking_vertex(GLenum mode)
{
	_impl::ProvokingVertex(mode);
}
inline void sample_maski(GLuint maskNumber, GLbitfield mask)
{
	_impl::SampleMaski(maskNumber, mask);
}
inline void tex_image2_d_multisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
	_impl::TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}
inline void tex_image3_d_multisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
	_impl::TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}
inline void wait_sync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
	_impl::WaitSync(sync, flags, timeout);
}

/* gl version 3.3 */
inline void bind_frag_data_location_indexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name)
{
	_impl::BindFragDataLocationIndexed(program, colorNumber, index, name);
}
inline void bind_sampler(GLuint unit, GLuint sampler)
{
	_impl::BindSampler(unit, sampler);
}
inline void delete_samplers(GLsizei count, const GLuint * samplers)
{
	_impl::DeleteSamplers(count, samplers);
}
inline void gen_samplers(GLsizei count, GLuint * samplers)
{
	_impl::GenSamplers(count, samplers);
}
inline GLint get_frag_data_index(GLuint program, const GLchar * name)
{
	return _impl::GetFragDataIndex(program, name);
}
inline void get_query_objecti64v(GLuint id, GLenum pname, GLint64 * params)
{
	_impl::GetQueryObjecti64v(id, pname, params);
}
inline void get_query_objectui64v(GLuint id, GLenum pname, GLuint64 * params)
{
	_impl::GetQueryObjectui64v(id, pname, params);
}
inline void get_sampler_parameter_iiv(GLuint sampler, GLenum pname, GLint * params)
{
	_impl::GetSamplerParameterIiv(sampler, pname, params);
}
inline void get_sampler_parameter_iuiv(GLuint sampler, GLenum pname, GLuint * params)
{
	_impl::GetSamplerParameterIuiv(sampler, pname, params);
}
inline void get_sampler_parameterfv(GLuint sampler, GLenum pname, GLfloat * params)
{
	_impl::GetSamplerParameterfv(sampler, pname, params);
}
inline void get_sampler_parameteriv(GLuint sampler, GLenum pname, GLint * params)
{
	_impl::GetSamplerParameteriv(sampler, pname, params);
}
inline GLboolean is_sampler(GLuint sampler)
{
	return _impl::IsSampler(sampler);
}
inline void query_counter(GLuint id, GLenum target)
{
	_impl::QueryCounter(id, target);
}
inline void sampler_parameter_iiv(GLuint sampler, GLenum pname, const GLint * param)
{
	_impl::SamplerParameterIiv(sampler, pname, param);
}
inline void sampler_parameter_iuiv(GLuint sampler, GLenum pname, const GLuint * param)
{
	_impl::SamplerParameterIuiv(sampler, pname, param);
}
inline void sampler_parameterf(GLuint sampler, GLenum pname, GLfloat param)
{
	_impl::SamplerParameterf(sampler, pname, param);
}
inline void sampler_parameterfv(GLuint sampler, GLenum pname, const GLfloat * param)
{
	_impl::SamplerParameterfv(sampler, pname, param);
}
inline void sampler_parameteri(GLuint sampler, GLenum pname, GLint param)
{
	_impl::SamplerParameteri(sampler, pname, param);
}
inline void sampler_parameteriv(GLuint sampler, GLenum pname, const GLint * param)
{
	_impl::SamplerParameteriv(sampler, pname, param);
}
inline void vertex_attrib_divisor(GLuint index, GLuint divisor)
{
	_impl::VertexAttribDivisor(index, divisor);
}
inline void vertex_attrib_p1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP1ui(index, type, normalized, value);
}
inline void vertex_attrib_p1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP1uiv(index, type, normalized, value);
}
inline void vertex_attrib_p2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP2ui(index, type, normalized, value);
}
inline void vertex_attrib_p2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP2uiv(index, type, normalized, value);
}
inline void vertex_attrib_p3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP3ui(index, type, normalized, value);
}
inline void vertex_attrib_p3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP3uiv(index, type, normalized, value);
}
inline void vertex_attrib_p4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	_impl::VertexAttribP4ui(index, type, normalized, value);
}
inline void vertex_attrib_p4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	_impl::VertexAttribP4uiv(index, type, normalized, value);
}

} //namespace gl
} //namespace aw
#endif//aw_gl_ext_opengl_h
