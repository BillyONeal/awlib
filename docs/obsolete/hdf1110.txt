HDF Data Format 1.1.1

This document is only for reference. It is not an official specification.

Table of Contents

1. Introduction
 1.1. Goals summary
 1.2. Terminology
2. Characters
 2.1. Character set
 2.2. Names
 2.3. White space
 2.4. Line breaks
 2.5. Strings
3. HDF document
 3.1. Overall structure
 3.2. Nodes
 3.3. Values
4. Typing
 4.1. Explicit typing
 4.2. Implicit typing


1. Introduction

HDF Data Format (or hrengin Data Format) is text-based data serialization format. It designed to be used specifically within 'hrengin' game engine, and to be easily read by human.

Another design goal for HDF is to be easy to implement and process.

Although HDF is designed primarily for use within 'hrengin' game engine, it is designed with possibility for general use in mind.

The language is designed to be easy to implement, easy to process and use, and easy to create by a human. It is also designed to be extensible, lightweight, simple and concise.

1.1. Relation to other languages

HDF is designed for narrow scope of use as a data serialization language. It is not based on any other language, though is inspired by some other languages, most notably ZenGin Archive and XML.

1.2 Terminology



2. Characters

2.1. Character set

The exact character set is yet to be determined.

2.2. Names

name is a sequence of characters. The first character must be a name_first, and the following characters are name_char.

[1] name ::= name_first name_char*

[2] name_first ::= [A-Z] | [a-z]

[3] name_char ::= [A-Z] | [a-z] | '-' | '_'

2.3. White space

White space consists of one or more spaces, tabs or line breaks.

[3] line_break ::= #xA | (#xA #xD)

[4] ws_char ::= #x9 | #x20

[5] s ::= (ws_char | line_break)+

Note: this definition does not yet account for the unicode range characters.

Inline white space is white space without line breaks.

[6] ws ::= ws_char+

2.4. Strings

string is a sequence of characters enclosed within '"' (quotation marks) characters.

[8] string ::= '"' char* '"'

2.4.1. Escape sequences

To be decided yet.


2.5. Numbers

[9]	number = sign? int fraction? exponent?

[10] digit = [0-9]

[11] int = digit+

[12] exponent = [Ee] sign? digit+

[13] fraction = '.' digit+

[14] sign = '+' | '-'

[15] hex-digit = digit | [a-f] | [A-F]

[16] hexadecimal = '0x' hex-digit+

3. HDF document

3.1. Structure

HDF document is composed of units called 'node', and must contain at least one of those.

Overall structure of a document can be defined as:

document ::= header? node+

This definition suggests following:

Document may contain header, preceding all other data.
Document contains one or more nodes.
Example of a simplest document:

[root-node]

3.2. Nodes

node is a basic unit of a document. Each node is delimited by node_start and node_end. Each node may have a node_type, followed by name or an empty name.

node	::=	node_start node_content? node_end

node_start ::= '[' node_type? name s
node_end ::= s? ']' s?

Each node may contain value or other nodes.

node_content ::= (node | value s?) +

Values must be separated from each other, however, it is not necessary to separate values from nodes, since node begins with a non-name char.

value-value ::= value (separator value-value | value-node)? s?
value-node ::= value (separator? node-value | node-node)? s?
node-value ::= node (separator? value-value | value-node)? s?
node-node ::= node (separator? node-value | node-value)? s?

Vlueas are separated by either semicolon (';') or a line break.

separator ::= ws? ';' | line_break s?

An empty node is a node without node_content.

An example HDF document.

[node
  [subnode
    [subsubnode1] [subsubnode2 value1=0; value2=5.0]
  ]
]
			
3.3. Values

Values represent actual data, they serve to store values of variables or constants, hence the name.

value ::= name ws? '=' ws? type? ws? data

Values have type, which can be defined explictily, or, for some types, implicitly  (see 4. Typing). Data representation depends on type.

An example HDF document, describing a simple geometric model.

[model 
  [shapes 
    [shape 
      type = sphere 
      radius = float:5.0 
    ] 
    [shape 
      type = sphere 
      radius = float:2.5 
      offset = float:0.0 5.0 0.0 
    ] 
  ] 
]

4. Typing

4.1. Explicit typing

Type contains information about representation of data.

type ::= name ws? ':'

Known types are: string, int, float, bool, vec2, vec3, vec4, raw

4.2. Implicit typing

If type is omitted, then it is determined from the token: if token is string, or name, then type is string. If token is number, then type is float. 

4.3. Data representation

float and int types are represented as number. 
Vectors (vec2-4) are represented as series of tokens, separated by inline white spaces.
raw value is represented as hexadecimal.
Boolean type can be either 'true', 'false', '0, or '1'.